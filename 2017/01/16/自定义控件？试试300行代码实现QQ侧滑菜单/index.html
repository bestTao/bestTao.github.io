<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="可以说是 ViewDragHelper 的最佳实践">
<meta name="keywords" content="Android,自定义控件">
<meta property="og:type" content="article">
<meta property="og:title" content="QQ 6.x 抽屉菜单">
<meta property="og:url" content="https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/index.html">
<meta property="og:site_name" content="Salama">
<meta property="og:description" content="可以说是 ViewDragHelper 的最佳实践">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/7e87f12fd3f252b119d1.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/b2d745f1dd49c5331524.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/48d0d02b811e9966e655.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/21792363be1f2ffce9b3.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/818eeb8270fe6ca23852.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://lc-gold-cdn.xitu.io/db3ed31c0a16a0584720.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2019-07-24T02:07:55.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QQ 6.x 抽屉菜单">
<meta name="twitter:description" content="可以说是 ViewDragHelper 的最佳实践">
<meta name="twitter:image" content="https://lc-gold-cdn.xitu.io/7e87f12fd3f252b119d1.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>QQ 6.x 抽屉菜单</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/archives/">列表</a></li>
         
          <li><a href="/emmm/">牢骚</a></li>
         
          <li><a href="/about/">我</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/01/04/Generate-Android-proguard-dictionary/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2016/12/18/《编写可读代码的艺术》-读书笔记/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&text=QQ 6.x 抽屉菜单"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&is_video=false&description=QQ 6.x 抽屉菜单"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=QQ 6.x 抽屉菜单&body=Check out this article: https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&name=QQ 6.x 抽屉菜单&description=&lt;p&gt;可以说是 ViewDragHelper 的最佳实践&lt;br&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#首先"><span class="toc-number">1.</span> <span class="toc-text">首先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定目标及方向"><span class="toc-number">2.</span> <span class="toc-text">确定目标及方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为滑动做准备"><span class="toc-number">3.</span> <span class="toc-text">为滑动做准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-的滑动"><span class="toc-number">4.</span> <span class="toc-text">main 的滑动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#menu的滑动"><span class="toc-number">5.</span> <span class="toc-text">menu的滑动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#给-main-加个滑动渐变阴影"><span class="toc-number">6.</span> <span class="toc-text">给 main 加个滑动渐变阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#还需要一些优化"><span class="toc-number">7.</span> <span class="toc-text">还需要一些优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">8.</span> <span class="toc-text">写在最后</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        QQ 6.x 抽屉菜单
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Salama</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-01-16T11:36:01.000Z" itemprop="datePublished">2017-01-16</time>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>, <a class="tag-link" href="/tags/自定义控件/">自定义控件</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>可以说是 ViewDragHelper 的最佳实践<br><a id="more"></a><br>Android 自定义控件并没有什么捷径可走，需要不断得模仿练习才能出师。这其中进行模仿练习的 demo 的选择是至关重要的，最优选择莫过于官方的控件了，但是官方控件动辄就是几千行代码往往可能容易让人望而却步。本文介绍如何理解并实现 Android 端的 QQ 抽屉菜单。<br>首先上完成的效果图：</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/7e87f12fd3f252b119d1.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" max-width="80%"><br></div>

<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>本文并不会长篇大论的讲解自定义控件所需要的从绘图、屏幕坐标系、滑动到动画等原理，因为我相信无论你是否会自定义控件，这些原理你都已经从别处烂熟于心了。但是为了方便理解，会在实现的过程中进行穿插讲解。</p>
<h2 id="确定目标及方向"><a href="#确定目标及方向" class="headerlink" title="确定目标及方向"></a>确定目标及方向</h2><p>动手撸代码前，我们看一眼这个效果。首先确定我们的目标是需要自定义一个 ViewGroup，需要控制它的两个子 View 进行滑动变换。进一步观察我们可以发现两个子 View 是叠加再一起的，所以为了减少代码我们可以考虑直接继承于 ViewGroup 的一个实现类：<code>FrameLayout</code>。底层的是菜单视图<code>menu</code>，叠加在上面的是主界面 <code>main</code>。<br>新建一个类：<code>CoordinatorMenu</code>，并在加载布局后拿到两个子 View<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorMenu</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> View mMenuView;</span><br><span class="line">    <span class="keyword">private</span> View mMainView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载完布局文件后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mMenuView = getChildAt(<span class="number">0</span>);<span class="comment">//第一个子 View 在底层，作为 menu</span></span><br><span class="line">        mMainView = getChildAt(<span class="number">1</span>);<span class="comment">//第二个子 View 在上层，作为 main</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为滑动做准备"><a href="#为滑动做准备" class="headerlink" title="为滑动做准备"></a>为滑动做准备</h2><p>实现手指跟随滑动，这其中有很多方法，最基本的莫过于重写 <code>onTouchEvent</code> 方法并配合 <code>Scroller</code> 实现了，但是这也是最复杂的了。还好官方提供了一个 <code>ViewDragHelper</code> 类帮助我们去实现（本质上还是使用Scroller）。<br>在我们的构造方法中通过 <code>ViewDragHelper</code> 静态方法进行其初始化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewDragHelper = ViewDragHelper.create(</span><br><span class="line">    <span class="keyword">this</span>,</span><br><span class="line">    TOUCH_SLOP_SENSITIVITY,</span><br><span class="line">    <span class="keyword">new</span> CoordinatorCallback());</span><br></pre></td></tr></table></figure></p>
<p>三个参数的含义：</p>
<ul>
<li>需要监听的 View，这里就是当前的控件</li>
<li>开始触摸滑动的敏感度，值越大越敏感，1.0f 是正常值</li>
<li>一个 Callback 回调，整个 ViewDragHelper 的核心逻辑所在，这里自定义了一个它的实现类</li>
</ul>
<p>然后拦截触摸事件，交给我们的主角 <code>ViewDragHelper</code> 处理：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将触摸事件传递给 ViewDragHelper，此操作必不可少</span></span><br><span class="line">    mViewDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理 <code>computeScroll</code> 方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//滑动过程中调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);<span class="comment">//处理刷新，实现平滑移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理部分Callback回调<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//告诉 ViewDragHelper 对哪个子 View 进行拖动滑动</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//侧滑菜单默认是关闭的</span></span><br><span class="line">    <span class="comment">//用户必定只能先触摸的到上层的主界面</span></span><br><span class="line">    <span class="keyword">return</span> mMainView == child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行水平方向滑动</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left;<span class="comment">//通常返回 left 即可，left 指代此 view 的左边缘的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="main-的滑动"><a href="#main-的滑动" class="headerlink" title="main 的滑动"></a>main 的滑动</h2><p>这样我们就能在水平方向上随意拖动上层的子 View – <code>main</code> 了，接下来就是限制它水平滑动的范围了，范围如下图所示：</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/b2d745f1dd49c5331524.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br></div>

<p>改写上面的水平滑动方法，<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        left = <span class="number">0</span>;<span class="comment">//初始位置是屏幕的左边缘</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mMenuWidth) &#123;</span><br><span class="line">        left = mMenuWidth;<span class="comment">//最远的距离就是菜单栏完全展开后的 menu 的宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>增加回弹效果：</strong></p>
<ul>
<li>当菜单关闭，从左向右滑动 <code>main</code> 的时候，小于一定距离松开手，需要让它回弹到最左边，否则直接打开菜单</li>
<li>当菜单完全打开，从右向左滑动 <code>main</code> 的时候，小于一定距离松开手，需要让它回弹到最右边，否则直接关闭菜单</li>
</ul>
<p>首先判断滑动的方向：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 view 位置改变时调用，也就是拖动的时候</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dx 代表距离上一个滑动时间间隔后的滑动距离</span></span><br><span class="line">    <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;<span class="comment">//正</span></span><br><span class="line">        mDragOrientation = LEFT_TO_RIGHT;<span class="comment">//从左往右</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dx &lt; <span class="number">0</span>) &#123;<span class="comment">//负</span></span><br><span class="line">        mDragOrientation = RIGHT_TO_LEFT;<span class="comment">//从右往左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在松开手后：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//View 释放后调用</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewReleased(releasedChild, xvel, yvel);</span><br><span class="line">    <span class="keyword">if</span> (mDragOrientation == LEFT_TO_RIGHT) &#123;<span class="comment">//从左向右滑</span></span><br><span class="line">        <span class="keyword">if</span> (mMainView.getLeft() &lt; mSpringBackDistance) &#123;<span class="comment">//小于设定的距离</span></span><br><span class="line">            closeMenu();<span class="comment">//关闭菜单</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();<span class="comment">//否则打开菜单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDragOrientation == RIGHT_TO_LEFT) &#123;<span class="comment">//从右向左滑</span></span><br><span class="line">        <span class="keyword">if</span> (mMainView.getLeft() &lt; mMenuWidth - mSpringBackDistance)&#123;<span class="comment">//小于设定的距离</span></span><br><span class="line">            closeMenu();<span class="comment">//关闭菜单</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            openMenu();<span class="comment">//否则打开菜单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.smoothSlideViewTo(mMainView, mMenuWidth, <span class="number">0</span>);</span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(CoordinatorMenu.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.smoothSlideViewTo(mMainView, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(CoordinatorMenu.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="menu的滑动"><a href="#menu的滑动" class="headerlink" title="menu的滑动"></a>menu的滑动</h2><p>展开后，我们就可以触摸到底层的 <code>menu</code> 视图了，我们拽 <code>menu</code> 不能拖动它本身，也不能拖动 <code>main</code>，因为我们在前面指定了触摸只作用于 <code>main</code>。我们可以先思考一下，QQ 的侧滑菜单底层是跟随上层移动的（细心的你会发现不是完全跟随的，它们之间的距离变化有个线性关系，这个稍后再说），这样的话那我们就可以把 <code>menu</code> 完全托付给 <code>main</code> 处理，分两步：1. <code>menu</code> 托付给 <code>main</code>; 2. <code>main</code> 滑动时管理 <code>menu</code> 的滑动。<br>首先我们要先确定 <code>menu</code> 的初始位置及大小，重写 <code>layout</code> 方法，向左偏移一个 <code>mMenuOffset</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    MarginLayoutParams menuParams = (MarginLayoutParams) mMenuView.getLayoutParams();</span><br><span class="line">    menuParams.width = mMenuWidth;</span><br><span class="line">    mMenuView.setLayoutParams(menuParams);</span><br><span class="line">    mMenuView.layout(-mMenuOffset, top, mMenuWidth - mMenuOffset, bottom);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>我们先实现第一步：触摸到 <code>menu</code>，交给 <code>main</code> 处理。</strong><br>在这之前改写前面的回调方法，让 <code>menu</code> 能接受触摸事件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainView == child || mMenuView == child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察被触摸的 view</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCaptured</span><span class="params">(View capturedChild, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capturedChild == mMenuView) &#123;<span class="comment">//当触摸的 view 是 menu</span></span><br><span class="line">        mViewDragHelper.captureChildView(mMainView, activePointerId);<span class="comment">//交给 main 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这一步后，我们就可以在手指触摸到 <code>menu</code> 的时候，拖动 <code>main</code>。<br><del>这个感觉就像是指桑骂槐，指着的是 <code>menu</code>，骂的却是 <code>main</code>，哈哈。</del></p>
<p><strong>接下来我们实现第二步，<code>menu</code> 跟随 <code>main</code> 滑动</strong><br>先看下面 <code>menu</code> 与 <code>main</code> 的位置关系图</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/48d0d02b811e9966e655.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br></div>

<p>很明显我们能得出一个结论：</p>
<blockquote>
<p>从 menu 关闭到 menu 的打开：menu 移动了它的初始向左偏移距离 <code>mMenuOffset</code>，main 移动了的距离正好是 menu 的宽度 <code>mMenuWidth</code></p>
</blockquote>
<p>所以我们就可以用之前用到的回调：<code>onViewPositionChanged(View changedView, int left, int top, int dx, int dy)</code>，因为这里的 <code>dx</code> 正是指代移动距离，只要 <code>main</code> 移动了一个 <code>dx</code>，那我们就可以让 <code>menu</code> 移动一个 <code>dx * mMenuOffset / mMenuWidth</code>，不就行了吗？<br>看起来十分美好，实践起来却是No!No!No!，因为需要对 <code>menu</code> 使用<code>layout</code> 方法进行重新布局以达到移动效果，而这个方法传进去的值是<strong>int</strong>型，而我们上面的计算公式的结果很明显是个<strong>float</strong>，况且很不巧的是这个 <code>dx</code> 是指 <strong>代表距离上一个滑动时间间隔后的滑动距离</strong>，就是把你整个滑动过程分割成很多的小块，每一小块的时间很短，如果你滑动很慢的话，那么在这很短的时间内 <code>dx=1</code> ，fuxk 。所以这样计算的话精度严重丢失，不能达到同步移动的效果。<br>所以我们只能换一种思维，使用它们之间的另一种关系：<code>menu</code> 左边缘和<code>main</code> 左边缘之间的距离是由 <code>mMenuOffset</code> 增加到 <code>mMenuWidth</code>，此时 <code>main</code> 移动了 <code>mMenuWidth</code>。可以认为这种增加是线性的，如下图所示：</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/21792363be1f2ffce9b3.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br></div>

<p>根据图及公式 <code>y = kx + d</code> 得出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mainLeft - menuLeft = (mMenuWidth - mMenuOffset) / mMenuWidth * mainLeft</span><br><span class="line">+ mMenuOffset</span><br></pre></td></tr></table></figure></p>
<p>所以这样重写回调 <code>onViewPositionChanged</code> 即可使 <code>menu</code> 跟随<code>main</code> 进行滑动变换：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> scale = (<span class="keyword">float</span>) (mMenuWidth - mMenuOffset) / (<span class="keyword">float</span>) mMenuWidth;</span><br><span class="line">    <span class="keyword">int</span> menuLeft = left - ((<span class="keyword">int</span>) (scale * left) + mMenuOffset);</span><br><span class="line">    mMenuView.layout(menuLeft, mMenuView.getTop(),</span><br><span class="line">            menuLeft + mMenuWidth, mMenuView.getBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信如果我没有给出上面的数学关系解答，直接看代码，你可能会一脸懵逼，这也是很多自定义控件源码难读的原因。</p>
<h2 id="给-main-加个滑动渐变阴影"><a href="#给-main-加个滑动渐变阴影" class="headerlink" title="给 main 加个滑动渐变阴影"></a>给 main 加个滑动渐变阴影</h2><p>经过上面的操作，感觉总体已经有了模样了，但还缺少一样东西，就是 <code>main</code> 经过菜单由关闭到完全打开的过程中，会有一层透明到不透明变化的阴影，看下面动图演示：</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/818eeb8270fe6ca23852.gif?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br></div>

<p>实现这个功能我们需要知道 ViewGroup 通过调用其 <code>drawChild</code> 方法对子 view 按顺序分别进行绘制，所以在绘制完 <code>menu</code> 和 <code>main</code> 后，我们需要绘制一层左边缘随 <code>main</code> 变化且上边缘、右边缘和下边缘不变的视图，而且这个视图的透明度也会变化。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);<span class="comment">//完成原有的子view：menu和main的绘制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shadowLeft = mMainView.getLeft();<span class="comment">//阴影左边缘位置</span></span><br><span class="line">    <span class="keyword">final</span> Paint shadowPaint = <span class="keyword">new</span> Paint();<span class="comment">//阴影画笔</span></span><br><span class="line">    shadowPaint.setColor(Color.parseColor(<span class="string">"#"</span> + mShadowOpacity + <span class="string">"777777"</span>));<span class="comment">//给画笔设置透明度变化的颜色</span></span><br><span class="line">    shadowPaint.setStyle(Paint.Style.FILL);<span class="comment">//设置画笔类型填充</span></span><br><span class="line">    canvas.drawRect(shadowLeft, <span class="number">0</span>, mScreenWidth, mScreenHeight, shadowPaint);<span class="comment">//画出阴影</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中这个 <code>mShadowOpacity</code> 是随 <code>main</code> 的位置变化而变化的：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String mShadowOpacity = <span class="string">"00"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> showing = (<span class="keyword">float</span>) (mScreenWidth - left) / (<span class="keyword">float</span>) mScreenWidth;</span><br><span class="line">    <span class="keyword">int</span> hex = <span class="number">255</span> - Math.round(showing * <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">if</span> (hex &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        mShadowOpacity = <span class="string">"0"</span> + Integer.toHexString(hex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mShadowOpacity = Integer.toHexString(hex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此我们的菜单可以说是完工了，but！</p>
<h2 id="还需要一些优化"><a href="#还需要一些优化" class="headerlink" title="还需要一些优化"></a>还需要一些优化</h2><p>1.如果打开菜单，熄屏，再亮屏，此时菜单就又恢复到关闭的状态了，因为重新亮屏后，<code>layout</code> 方法会重新调用，也就是说我们的子 view 会重新布局，所以要改写这个方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    MarginLayoutParams menuParams = (MarginLayoutParams) mMenuView.getLayoutParams();</span><br><span class="line">    menuParams.width = mMenuWidth;</span><br><span class="line">    mMenuView.setLayoutParams(menuParams);</span><br><span class="line">    <span class="keyword">if</span> (mMenuState == MENU_OPENED) &#123;<span class="comment">//判断菜单的状态为打开的话</span></span><br><span class="line">        <span class="comment">//保持打开的位置</span></span><br><span class="line">        mMenuView.layout(<span class="number">0</span>, <span class="number">0</span>, mMenuWidth, bottom);</span><br><span class="line">        mMainView.layout(mMenuWidth, <span class="number">0</span>, mMenuWidth + mScreenWidth, bottom);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mMenuView.layout(-mMenuOffset, top, mMenuWidth - mMenuOffset, bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取菜单的状态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMainView.getLeft() == <span class="number">0</span>) &#123;</span><br><span class="line">        mMenuState = MENU_CLOSED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMainView.getLeft() == mMenuWidth) &#123;</span><br><span class="line">        mMenuState = MENU_OPENED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.旋转屏幕也会出现上述的问题，这时就需要调用 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 这两个方法分别用来保存和恢复我们菜单的状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedState</span> <span class="keyword">extends</span> <span class="title">AbsSavedState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> menuState;<span class="comment">//记录菜单状态的值</span></span><br><span class="line"></span><br><span class="line">    SavedState(Parcel in, ClassLoader loader) &#123;</span><br><span class="line">        <span class="keyword">super</span>(in, loader);</span><br><span class="line">        menuState = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.writeToParcel(dest, flags);</span><br><span class="line">        dest.writeInt(menuState);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</span><br><span class="line">    <span class="keyword">final</span> CoordinatorMenu.SavedState ss = <span class="keyword">new</span> CoordinatorMenu.SavedState(superState);</span><br><span class="line">    ss.menuState = mMenuState;<span class="comment">//保存状态</span></span><br><span class="line">    <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Parcelable state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state <span class="keyword">instanceof</span> CoordinatorMenu.SavedState)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CoordinatorMenu.SavedState ss = (CoordinatorMenu.SavedState) state;</span><br><span class="line">    <span class="keyword">super</span>.onRestoreInstanceState(ss.getSuperState());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss.menuState == MENU_OPENED) &#123;<span class="comment">//读取到的状态是打开的话</span></span><br><span class="line">        openMenu();<span class="comment">//打开菜单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>避免过度绘制</strong>。<code>menu</code> 和 <code>main</code> 在滑动过程中会有重叠部分，重叠部分也就是 <code>menu</code> 被遮盖的部分，是不需要再绘制的，我们只需要绘制显示出来的 <code>menu</code> 部分，如图所示：</p>
<div align="center"><br>    <img src="https://lc-gold-cdn.xitu.io/db3ed31c0a16a0584720.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br></div>

<p>在 <code>drawChild</code> 方法中增加以下代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> restoreCount = canvas.save();<span class="comment">//保存画布当前的剪裁信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = getHeight();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> clipLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> clipRight = mMainView.getLeft();</span><br><span class="line">    <span class="keyword">if</span> (child == mMenuView) &#123;</span><br><span class="line">        canvas.clipRect(clipLeft, <span class="number">0</span>, clipRight, height);<span class="comment">//剪裁显示的区域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);<span class="comment">//绘制当前 view</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复画布之前保存的剪裁信息</span></span><br><span class="line">    <span class="comment">//以正常绘制之后的 view</span></span><br><span class="line">    canvas.restoreToCount(restoreCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>至此，我们的侧滑菜单即实现了功能，又优化并处理了些细节。如果有时候遇到功能不知道怎么实现，其实最好的解决方向就是先看看官方有没有实现过这样的功能，再去他们的源码里寻找答案，比如说我这里实现的阴影绘制以及过度绘制优化都是参照于官方控件 <code>DrawerLayout</code>，阅读官方源码不仅能让你实现功能，还能激发你并改善你的代码质量，会有一种 <code>卧槽，代码原来应该这么写</code> 的感叹。</p>
<blockquote>
<p>本文源码地址：<a href="https://github.com/bestTao/CoordinatorMenu" target="_blank" rel="noopener">https://github.com/bestTao/CoordinatorMenu</a>，<strong>有问题欢迎提issue</strong>。</p>
</blockquote>
<p><strong>你也可以直接在项目中引入这个控件：</strong></p>
<ol>
<li><p>先添加以下代码到你项目中的根目录的<code>build.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再引入依赖即可：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.github.bestTao:CoordinatorMenu:v1.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>详细内容及最新版本可以参考 <a href="https://github.com/bestTao/CoordinatorMenu/blob/master/README.md" target="_blank" rel="noopener">[README.md]</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/archives/">列表</a></li>
         
          <li><a href="/emmm/">牢骚</a></li>
         
          <li><a href="/about/">我</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#首先"><span class="toc-number">1.</span> <span class="toc-text">首先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定目标及方向"><span class="toc-number">2.</span> <span class="toc-text">确定目标及方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为滑动做准备"><span class="toc-number">3.</span> <span class="toc-text">为滑动做准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-的滑动"><span class="toc-number">4.</span> <span class="toc-text">main 的滑动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#menu的滑动"><span class="toc-number">5.</span> <span class="toc-text">menu的滑动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#给-main-加个滑动渐变阴影"><span class="toc-number">6.</span> <span class="toc-text">给 main 加个滑动渐变阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#还需要一些优化"><span class="toc-number">7.</span> <span class="toc-text">还需要一些优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">8.</span> <span class="toc-text">写在最后</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&text=QQ 6.x 抽屉菜单"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&is_video=false&description=QQ 6.x 抽屉菜单"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=QQ 6.x 抽屉菜单&body=Check out this article: https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&title=QQ 6.x 抽屉菜单"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/&name=QQ 6.x 抽屉菜单&description=&lt;p&gt;可以说是 ViewDragHelper 的最佳实践&lt;br&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 qiantao
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/archives/">列表</a></li>
         
          <li><a href="/emmm/">牢骚</a></li>
         
          <li><a href="/about/">我</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-120844447-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'Salama';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


