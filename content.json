{"meta":{"title":"钱吃菜","subtitle":"钱吃菜","description":"好奇心驱动","author":"qiantao","url":"https://qiantao94.github.io","root":"/"},"pages":[{"title":"","date":"2018-06-14T01:27:03.380Z","updated":"2018-06-14T01:27:03.380Z","comments":true,"path":"baidu_verify_Osq25Lj3Mj.html","permalink":"https://qiantao94.github.io/baidu_verify_Osq25Lj3Mj.html","excerpt":"","text":"Osq25Lj3Mj"},{"title":"","date":"2018-06-13T12:40:48.618Z","updated":"2018-06-13T12:40:48.614Z","comments":true,"path":"google21078a069b3abc66.html","permalink":"https://qiantao94.github.io/google21078a069b3abc66.html","excerpt":"","text":"google-site-verification: google21078a069b3abc66.html"},{"title":"我","date":"2019-07-24T02:04:20.887Z","updated":"2019-07-24T02:04:20.887Z","comments":false,"path":"about/index.html","permalink":"https://qiantao94.github.io/about/index.html","excerpt":"","text":"我，全站法师，代码即魔法。 ……"},{"title":"列表","date":"2018-11-06T01:07:44.000Z","updated":"2018-11-06T01:19:37.872Z","comments":true,"path":"begging/index.html","permalink":"https://qiantao94.github.io/begging/index.html","excerpt":"","text":""},{"title":"牢骚","date":"2018-11-05T08:52:49.000Z","updated":"2018-11-06T01:19:44.747Z","comments":true,"path":"emmm/index.html","permalink":"https://qiantao94.github.io/emmm/index.html","excerpt":"","text":""}],"posts":[{"title":"程序员的效率指南 —— 时间管理","slug":"time-manage","date":"2019-03-09T04:00:14.000Z","updated":"2019-07-24T01:58:03.963Z","comments":true,"path":"2019/03/09/time-manage/","link":"","permalink":"https://qiantao94.github.io/2019/03/09/time-manage/","excerpt":"","text":"想要提高学习、工作效率？看本指南就够了！ 本指南的第二篇，谈谈时间，这个我们熟悉又陌生的朋友。 GTD 与原则解决线上问题的时候，心里总想着还没有写完的代码；看书的时候，还挂念着未追完的剧。一个想法总是翻来覆去，就像是大脑中的「隐藏进程」，时不时地发个消息提醒你一下。这些都是效率低下的原因。想要在处理事务的时候能达到心如止水的状态，就不得不提 GTD (Get Things Done) 。它其实就分为 5 个动作：收集、整理、组织、检查、做。 读过「笔记篇」的读者都知道，关于效率，有一个非常重要的原则，收集加整理，GTD 的前半部分也是如此。 像清空收件箱一样，完全清空你的大脑，将大脑中任何的想法和规划，都列下来。收集事情的同时也是给大脑减负。至于把要做的事情列在哪里呢？市面上有很多解决这样需求的 To-Do 类软件，比如微软家的https://todo.microsoft.com 。 整理已经列出的所有事情，整理的时候可以使用「四象限法则」 就是根据事情的重要紧急程度来划分， 第 ① 象限的，马上去做。如果这个象限的任务很多，肯定会让人疲惫不堪，所以就需要反思一下自身或所处的环境，不可能什么事情都是即重要又紧急的，尽量把它们划分到第 ② 象限或第 ③ 象限。 第 ② 象限的，计划着去做，这里的事情是需要我们重点关注的，一天中主要的精力和工作时间都应该放在这里。 第 ③ 象限的，尽量委托别人做。这里的别人不局限于真人，也可以是工具。 第 ④ 象限的，尽量不去做。你可以将它们归档，以便日后计划，或者，直接扔掉。 要记住「四象限法则」也只是一个工具，重要的是，我们需要了解自身，什么事情该做，什么事情不用做，毕竟人一天的时间、精力是都是有限的。 事情都已经整理好了，那么该开始执行了。在执行之前，我们最后来了解一下 GTD 的后半部分。还记得我们需要重点关注的第 ② 象限吗，这里任务对你来说很重要，但又不急于完成，所以你要对它们做好提前规划，尽量细化任务的执行步骤，想好这个任务的目标是什么。然后就去执行，适时的去回顾任务的进展。别忘了第 ④ 象限中被归档的任务，你可以重新评估它们，这时候你会发现，有的可以提上日程，有的可以直接丢弃。 番茄工作法与工时预估GTD 的后半部分，想要真正落实对任务的实施和追踪，我们还需借鉴一下「番茄工作法」。番茄工作法中的番茄就是一个工作单元，1 个番茄 30 分钟 = 25 分钟工作 + 5 分钟休息，每完成 1 个番茄，记录一下任务进度，完成了 4个 这样的番茄，就需要长时间休息 15 到 30 分钟。 重点在于，每一个番茄不可暂停，每一个番茄内的工作时间，如果分心或者被打断，这个番茄则作废，需重新开始计算。完全按照番茄工作法，不仅对自身是一个挑战，同时对工作环境的要求也很严格。想象一下，你会被各种各样的事情打断，测试报 bug、产品提需求以及乱七八糟的会议。 我们需要借鉴的是它的思想，这个工作法之所以这样设计的原因只有一个，专注。人的专注时间并没有想象的那么长，设定一小段一小段的 25分钟工作时间；只有连续不断的专注才是有效的，所以不可暂停也不可打断；短时间的休息能辅助我们对专注力的使用；而长时间对专注力的消耗，是需要一段长时间的休息，以能保证下一段时间的专注。 番茄工作法最大作用就是能帮我们预估时间。对于很多程序员来说，可能工作中最拿不准的事情就是评估工作量和预估工时了，只能靠感觉来，感觉出了偏差，就可能会导致项目延期。然而使用过番茄工作法后，我们就能真正感知到时间是如何流逝的。通过番茄记录，能看到每一个任务、每一项工作，花费了多长时间；做这项工作，我的时间都耗在哪一步了？是不是可以改进？所以，我强烈建议你创造条件的去尝试一下，通过番茄工作法，来做我们规划好的任务。 多线程工作与时间黑洞不要多线程工作！同时做多件事情，看起来能提高效率，其实是反其道而行之，为什么？多线程工作就意味着需要多任务切换。作为程序员，肯定知道，任务切换需要耗费许多额外的花销，通俗地来讲，首先需要保存当前上下文以便下次能够顺利切换回来，然后要加载目标任务的上下文。如果一个系统不停地在多个任务之间来回倒腾，就会耗费大量的时间在上下文切换上，无形中浪费很多的时间。我们其实是在做一件事情，只不过我们在频繁的切换任务，看起来像是在做多件事情。 不仅如此，大脑开始一件任务的时候必须需要一定的时间来「热身」—— 需要一定时间来进入专注的工作或学习的状态。频繁的切换意味着你每件事都无法进入状态。 这里，并不完全否定「同时做多件事」，你可以将一件并不怎么费脑细胞的事情和一件需要投入专注力的事情组合起来，比如，边跑步边听书、边听歌边写代码。 多任务切换，会无形中浪费掉很多时间，这是我们很难察觉到的，这些时间就像是被黑洞给吸走了。我在之前的文章中提到过，频繁的群聊消息通知，对你的干扰，会形成巨大的时间黑洞。不仅如此，还有手机里各类 app 的消息通知，也会时不时地打扰正在专注工作的你。来自工作环境的干扰不可避免，我们要做的是尽可能地排除掉自身的负面影响，用 GTD 给自己的大脑减负、明确目标，用番茄工作法了解如何专注，避免多线程工作来避免时间黑洞。","categories":[],"tags":[{"name":"效率","slug":"效率","permalink":"https://qiantao94.github.io/tags/效率/"},{"name":"时间管理","slug":"时间管理","permalink":"https://qiantao94.github.io/tags/时间管理/"}]},{"title":"程序员的效率指南 —— 笔记篇","slug":"master-in-note","date":"2019-03-06T10:31:43.000Z","updated":"2019-07-24T02:06:39.981Z","comments":true,"path":"2019/03/06/master-in-note/","link":"","permalink":"https://qiantao94.github.io/2019/03/06/master-in-note/","excerpt":"","text":"工欲善其事，必先利其器。高效的工作、学习方法，能够事半功倍，这是我们都知道的。关于效率，如今已经有很多成熟的方法论以及工具，同时它们也是普适性的，缺乏对程序员这个特殊群体的针对性指导，于是就有了这个系列的指南。” 本指南的第一篇文章，我们来谈谈在学习的过程中，最容易被忽视的一个环节 —— 笔记。 从原则到实践这里有一条原则，是我们谈及效率的方法论时所避不开的，它十分简单，就是两步： 收集 整理 记笔记这件事，也是遵循这两步！ 而我们可能只做到了第一步收集。无论是印象笔记还是有道云笔记，大家用的最顺手的功能就是它的「剪裁」了。鼠标轻轻一点，笔记本就新增了一篇好文，那一刻，仿佛自己也轻松收获了新的知识。随后，这篇文章就被扔在那儿不管了。久而久之，文章越来越多，这已经不是笔记本了，更像是仓库，更像是杂货间。 所以整理这一步是最重要的，没有经过整理的笔记不能称之为笔记，顶多算作是摘抄。 打开笔记软件，这里以印象笔记为例，建立两个笔记本，分别对应原则中两步： 收集箱 — 无论是剪裁（将剪裁的默认笔记本设置为它），还是大脑中一闪而过的灵感，我们都应该先放入这里。仓库的角色应由它来扮演。 知识库 — 定期清理「收集箱」，将清理好的笔记存入这里。它才是真正意义上的笔记本。 对于剪裁而来的文章，只收集经过自己的思考和消化的内容，再附上原文链接或部分索引。 对于自己的灵感随笔，进行二次总结和归纳。 善用笔记软件的「标签系统」，在整理的时候，对所有的笔记都打上相应的「标签」，刚开始凭感觉打就行，后期回顾的时候再慢慢修改。 之所以使用标签而不是文件夹的形式来管理自己的笔记，是因为，一篇笔记只能放进一个文件夹，却能拥有多个标签，用标签代表笔记的类型和领域。标签的数量代表了知识横向上的广度，而每个标签下的笔记数量则能代表相应知识纵向上的深度。 代码片段与 Gist不同于其他群体，程序员们的笔记中有很大一部分，都是围绕着某一段代码进行的。代码片段不同于普通的文本，对格式是有要求的，这是为了方便阅读以及二次编辑。记录这样特殊的内容，普通的笔记软件是远远不够的。程序员交友社区 Github 已经为了我们提供了一个非常好的服务：Gist，Gist 可以帮你托管某个代码文件或是某个代码文件中的某个代码片段，每一个 Gist 都是一个 Git 仓库，这意味着它能被 clone、fork，当然也可以直接链接分享。如果你愿意的话，你还可以通过 Gist 将代码插入自己的博客中。 如何用 Gist 管理我的代码？Gist 的创建操作十分容易，直接网页端操作即可。当然，有更方便的方法，现如今主流的 IDE、编辑器都支持并整合了 Gist 的功能。比如广受欢迎的 IEDA 系列： 对于 Gist 的查看和编辑，网页端的管理功能就不是那么让人满意了，在这里，我推荐使用 Lepton，这款使用 Electron 编写的跨平台客户端，被赞誉为「程序员的印象笔记」。 这里友情提醒一下，畅快地使用 Gist ，需要通过科学上网的方式，原因大家都懂的。 笔记的终极奥义会的知识，不一定会表述出来。将头脑中的知识或想法与人进行交流，对知识是一种很好的自我巩固、自我优化。而最好的交流方式就是文字，容易被复制，容易被传播。所以记笔记的终极奥义就是将其写成文章，写文章是一个将自己所学知识、所记的零散笔记进行系统化的过程，在这个过程，你会不断加强对知识的认识、发现并弥补自己的不足。所以，当你记了很多了笔记以后，我建议你挑一个出来，试着写成文章。","categories":[],"tags":[{"name":"效率","slug":"效率","permalink":"https://qiantao94.github.io/tags/效率/"},{"name":"时间管理","slug":"时间管理","permalink":"https://qiantao94.github.io/tags/时间管理/"}]},{"title":"我们眼中 RxJava 式的网络请求","slug":"best-practice-in-rxjava-network-method","date":"2019-02-25T11:19:44.000Z","updated":"2019-07-24T02:07:38.968Z","comments":true,"path":"2019/02/25/best-practice-in-rxjava-network-method/","link":"","permalink":"https://qiantao94.github.io/2019/02/25/best-practice-in-rxjava-network-method/","excerpt":"诞生 5 年之久的 RxJava，已经不只是一个开源库，可以说它的诞生改变了我们写代码的方式，把它比作「神兵利器」也毫不为过。","text":"诞生 5 年之久的 RxJava，已经不只是一个开源库，可以说它的诞生改变了我们写代码的方式，把它比作「神兵利器」也毫不为过。我们现在已经能看到各式各样名为「最佳实践」的使用教程，如果我们没能用好这把利器，不仅不会发挥它的作用，反而会伤着我们自己。 回顾它的诞生原因，是为了解决回调地狱 (callback hell) 以及麻烦的线程切换。在 Android 开发中，哪个地方最会出现多层的回调嵌套以及频繁的线程切换呢？对！没错！是「网络请求」。所以 RxJava、Retrofit 这俩兄弟总会一起出现的，我们项目中关于 RxJava 的使用，也几乎都和网络请求相关。 过去的经验最初我们对 RxJava + Retrofit 的使用经验都是来源于 RxJava 与 Retrofit 结合的最佳实践 这篇文章，相信大家都看过。这篇文章中的基本封装思想是：订阅每个网络请求的流，将流的订阅结果再通过回调的方式返给流（也就是网络请求）的创建者。 如下所示： //HttpMethodpublic void getTopMovie(final ResultListener listener, int start, int count)&#123; movieService.getTopMovie(start, count) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber()&#123; @Override public void onStart() &#123;&#125; @Override public void onNext(Subject t) &#123; listener.onNext(t) &#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onCompleted() &#123;&#125; &#125;)&#125;//ActivityHttpMethods.getInstance().getTopMovie(new ResultListener()&#123; @Override public void onNext(Subject t)&#123; //handle result &#125;&#125;, 0, 10) 有什么问题？这种封装方式，对于初步的使用以及简单的项目，是没有问题的。但是遇到复杂一点的网络请求，它的扩展性就不那么灵活了： 多个连续的网络请求怎么写？按照上面的那种封装方式，我们有两种选择 拆解这个请求，在 subscribe 之前通过 flatMap 发起第二个或者第三个网络请求。这种写法肯定会影响项目中已有的外部调用。 在 onNext 中发起第二个请求，再在第二个网络请求的 onNext 中发起第三个网络请求……这一层又一层的回调嵌套，正是用 RxJava 所能解决、避免的这样写，我们就又回到了最初的原点。 怎么取消网络请求？不取消，意味着内存泄露的风险。 回到 RxJava 本身RxJava 提供给我们的、我们所中意的强大之处在哪？在于它的「操作符」，map、flatMap、zip 等等，甚至线程的切换 subscribeOn、observeOn 也是操作符。RxJava 的各种强大的功能就是通过各式各样的「操作符」实现的。 操作符操作的是什么？流。流（Observable、Flowable）是 RxJava 的基本单位。所以一套链式请求拆开应该是这样的： 所以说，网络请求库对外提供网络请求的结果应该是以「流」的形式进行提供： 单个网络请求，对外提供单个「流」 多个网络请求，将多个网络请求结果流通过「操作符」组合成一个「流」对外提供 持久化：网络请求结果流和持久化的缓存流，总能通过「操作符」组合成一个对外提供的结果「流」 我们需要背压吗？当生产者大于消费者，则市场价格会降低，则会产生背压问题（Backpressure）。解决背压有很多种策略，RxJava2 中的 Flowable 天然支持背压。所以 Flowable 这个万金油，不管三七二十一，直接拿来用是没有问题的。 但是，网络请求，会产生背压问题吗？不会，为了防止抬杠，可以说大部分情况下是不会的。网络请求的每一个流，即用即走，上游的生产者（Request）和下游的消费者(Responese)，永远是一对一的关系，不会出现连续的事件流。杀鸡焉用牛刀，所以我们可以退一步，改用 Observable。 网络请求不会出现连续的事件流，在 onNext 出现之后，onComplete 马上就会被调用，所以只需要这两者中的一个就够了，也就不用考虑 Observable，同样 Maybe 也是可以排除的。 剩下的也就只有 Single 和 Completable 了，相对于 Single，Completable 没有 map 和 flatMap 方法。所以需要进一步处理网络请求结果的我们，可以选择使用 Single。 抛出异常网络请求过程，协议层的异常会自动抛至 onError() ，如 404、503 错误。对于如下有请求结果但无目标请求数据，我们也应当作为异常来处理： &#123; \"code\": \"6002\", \"msg\": \"公钥为空\"&#125; 毕竟这样的请求结果，是后端经过异常处理返回给我们的。 假定我们的请求结果是这样的范式： data CommonResult&lt;T&gt;( var code: Int = 0, var data: T? = null, var message: String? = null) 我们活用 RxJava 的操作符，用 map 来处理请求到的 ResponseBody (这也是前面选择 Single 的原因)，为了便于复用，可以定义一个这样的 mapper: class CommonResultMapper&lt;T&gt; : Function&lt;CommonResult&lt;T&gt;, T&gt; &#123; override fun apply(t: CommonResult&lt;T&gt;): T &#123; val data = t.data if (t.code == SUCCESS_CODE &amp;&amp; data != null) &#123; return data &#125; else &#123; //抛出异常 throw Throwable(\"请求 $t 失败\") &#125; &#125;&#125; 使用这个定义好的 mapper： @GET(PUSH_URL)fun fetchTag(@Query(\"udid\") udid: String): Single&lt;CommonResult&lt;Tag&gt;&gt;fun fetchTagResult(udid: String): Single&lt;Tag&gt; &#123; return netService.fetchTag(udid) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(CommonResultMapper())&#125; 如果你愿意，你还可以将线程切换和数据处理结合在一起，使用 RxJava 的 Transformer //定义一个 transformerfun &lt;T&gt; resultTransformer(): SingleTransformer&lt;CommonResult&lt;T&gt;, T&gt; &#123; return SingleTransformer &#123; single -&gt; single.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .map(CommonResultMapper()) &#125;&#125;//使用fun fetchTagResult(udid: String): Single&lt;Tag&gt; &#123; return netService.fetchTag(udid) .compose(resultTransformer())&#125; 使用这样封装，结果归结果，异常归异常。 fetchTagResult(\"123321\") .subscribeBy( onSuccess = &#123; tag -&gt; //结果 &#125;, onError = &#123; e -&gt; //异常 &#125; ) 回顾上图中的对内封装和对外可见，在得到真正想要的网络请求结果之前，需要一直保持对内封装的状态。因此，如果需要同时或者按顺序发起多个网络请求，那么就应该在对内封装中进行操作，例如可以使用 flatMap 按顺序发起第二个网络请求： fun fetchUserSingle(tag: Tag): Single&lt;User&gt; &#123; return netService.fetchUser(tag)&#125;fun fetchUserResult(udid: String): Single&lt;User&gt; &#123; return netService.fetchTag(udid) .compose(resultTransformer()) .flatMap&#123; tag -&gt; //使用第一个请求的结果作为第二个请求的参数 return@flatMap fetchUserSingle(tag) &#125;&#125; 无论如何，善用操作符，我们的代码总会是「链式」的。 取消网络请求与内存泄漏最后还需要关注一下这里的内存泄漏问题，在 Activity 销毁时，要及时取消掉这些已经失去上下文意义的网络请求。这里我们及时 unsubscribe 就好了。 同时在管理生命周期方面，也有更成熟的方案：RxLifecycle。 以上","categories":[],"tags":[{"name":"RxJava","slug":"RxJava","permalink":"https://qiantao94.github.io/tags/RxJava/"},{"name":"网络","slug":"网络","permalink":"https://qiantao94.github.io/tags/网络/"}]},{"title":"build:gradle 3.0 以及 Support Library 27.1.0 带来的 Api 变动","slug":"new-api-in-gradle-3-0-and-support-library-27-1-0","date":"2018-09-03T13:54:48.000Z","updated":"2019-07-24T02:06:41.708Z","comments":true,"path":"2018/09/03/new-api-in-gradle-3-0-and-support-library-27-1-0/","link":"","permalink":"https://qiantao94.github.io/2018/09/03/new-api-in-gradle-3-0-and-support-library-27-1-0/","excerpt":"","text":"Google 又双叒升级了 Android 的开发库，我们将根目录下的 build:gradle 版本由原先的 2.3.3 升级至 3.1.2，随之带来的问题是 Support Library 也需要升级。升级之后，gradle 脚本以及 support 包下相关类的 Api 发生了重大的改动。具体需要注意的改动如下： build.gradle 文件引入依赖的方式由原来的 compile 变更为现在的 implementation 和 api 关键字，这两个关键字的区别在于是否能传递依赖，例如： 注意：使用旧的关键字 compile 进行依赖应用并不会报错，只会报警告。使用 implementation 可以提升编译速度。 Support Library 27新的 support 包带来便捷的新特性，如自带生命周期组件中的 android.arch.lifecycle:runtime 库，但对现有代码对兼容带来不小的麻烦。 ⚠️最明显的变化就是 Fragment 中的 getActivity() 以及 getContext() 方法返回的被标记为 @Nullable, 也就是返回值可能为 null , 于是在 Kotlin 中所有获取 Activity、Context 实例的地方都需要判空操作。 其实 Google 并没有更改代码逻辑，返回 null 是因为 fragment 没有加入到 actiivty 中，这个逻辑处理之前的版本就存在，只是相比之前加上 @Nullable 注解，具体可以看这里的解释：https://stackoverflow.com/a/49289578/7077907 。 如何更好的兼容之前的代码？直接加 !! 处理是没有问题的，如果你觉得这样写过于丑陋并且看起来十分危险，可以用 activity ? : return 这样的写法代替，或者更好的方式是使用 Google 新提供的方法： requireActivity()requireContext() 这两个方法的返回值是不为 null 的，内部作了判空抛异常处理。具体文档可看源码或这里：https://developer.android.com/topic/libraries/support-library/revisions#27-1-0。 以上。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"gradle","slug":"gradle","permalink":"https://qiantao94.github.io/tags/gradle/"},{"name":"support-library","slug":"support-library","permalink":"https://qiantao94.github.io/tags/support-library/"}]},{"title":"背单词 * 365天","slug":"emmm/momo-365","date":"2018-08-02T02:52:16.000Z","updated":"2019-09-08T10:16:24.498Z","comments":true,"path":"2018/08/02/emmm/momo-365/","link":"","permalink":"https://qiantao94.github.io/2018/08/02/emmm/momo-365/","excerpt":"","text":"\b墨墨背单词打卡 365天 留念。 🎉🎉🎉 这一年的时间里，每一个工作日的开始，都充满仪式感。挤进地铁，只要过两站，趁着别人下车换乘的间隙，就能挤到稍微宽敞的列车衔接处，掏出手机，戴上耳机，打开「墨墨背单词」，开始了背单词，大约过 14站，我就能背完复习加上新增的总共 50个 单词。这期间换过一次工作，但是也没有断过。 除了能增加生活的仪式感，背单词本身并没有对提高词汇量这件事有太大的帮助。单纯的背单词，没有使用场景，形成记忆的难度很大，只能靠机械性的复习，慢慢加固记忆。这就导致我背的速度跟不上忘的速度，带来的挫败感还是挺大的。 所以，我会在恰当的时间，停止这样机械式的背单词，去寻找其他的方式。当然，那时我的生活便少了一份这样的仪式感。","categories":[{"name":"emmm","slug":"emmm","permalink":"https://qiantao94.github.io/categories/emmm/"}],"tags":[]},{"title":"张一鸣的「及时满足」生意","slug":"emmm/tittytainment","date":"2018-07-07T04:14:26.000Z","updated":"2019-09-08T10:16:35.398Z","comments":true,"path":"2018/07/07/emmm/tittytainment/","link":"","permalink":"https://qiantao94.github.io/2018/07/07/emmm/tittytainment/","excerpt":"","text":"回想之前的「头腾大战」， 头条的碰瓷式营销让我涨了见识。有好事者在即刻上开了个问答：“头腾大战你支持谁？”，其中有一个回答让我眼前一亮：“张一鸣信奉延迟满足，所以我支持腾讯”。这句话是什么意思呢？解读一下大概就是：信奉「延迟满足」的张一鸣深谙人性中的「及时满足」，并把它铸成一把锋利的镰刀，收割了一波又一波的灵魂。然后这些灵魂便铸就了他现在的商业帝国。 躲过一劫我时常感到自己很幸运，比如自己一开始就很拒绝头条系的产品，很幸运的躲过一劫，躲过了「抖音」这一劫。还记得当我第一次打开今日头条的时候，我就被满屏的标题党给吓到了。彼时的我就十分的抵触 UC 的震惊体以及微博上的路边八卦文，而头条却满满充斥着这些（彼时的头条充斥着这些东西不奇怪，因为头条不生产内容，大部分的内容都是从 UC 、微博这些站上爬来的）。 头条不错的爬虫技术加上越来越优秀的算法推荐，很容易就让人沉浸在一屏又一屏的信息流中去，一旦你养成了看头条的习惯，加上移动平台的便捷性，你会发现你所有的碎片时间都被这个玩意吞噬了，像其他成瘾行为一样，很难戒掉。说其是时间黑洞也不为过！ 相比较于图文类的信息，短视频所包含的信息更加丰富，所带来的感官刺激也更加直接，它显然比图文让人易于理解，所以更容易让人接受并成瘾。当然了，作为头条的子产品，抖音它同样也拥有优秀的推荐算法以及让人无法自拔的无限瀑布流。 及时满足及时满足欲望是人的本能。人是动物，生而就有满足自己欲望的本能。所以前面提到了，张一鸣他深谙人性中的「及时满足」，你有欲望，他给你满足。 他甚至都不需要洞悉人性，人性都在用户行为数据里摆着呢，在算法和无数个A/B测试面前，用户根本不是人，只不过是一行行可以反复优化的数字，汇集成千万个CPC，最终转化成银行账户里跳动着增加的数字。 作为时间杀手，它们不仅仅是吞噬掉你的时间，它们还会不知不觉的破坏人的意志力。因为同样是满足欲望，这种方式要比「努力坚持达成人生目标」所带来的快乐和舒适要简单方便的多！ 当你一旦习惯了这种碎片化的舒适，你就很难再沉下去认真看一本书，甚至很难再静下心来看一部经典的老电影。你明明知道那是有益处的，但就是难以选择它们。因为暂时的快乐要好过那些远期才可以兑换的好处。 奶头乐就算没有张一鸣，没有头条，没有抖音的存在，人们还是往往会陷入其他「及时满足」的泥沼中去，因为这里面有深层次的社会原因——奶头乐。 奶头乐（英语：tittytainment），又译为奶头娱乐[1]，是美国前国家安全顾问布热津斯基提出来的理论，来自于英文“titty”（奶头）与“entertainment”（娱乐）两词的组合，特别泛指那一类能让人着迷、又低成本、能够使人满足的低俗娱乐内容。用来描述一个设想：由于生产力的不断上升，世界上的一大部分人口将会不用也无法积极参与产品和服务的生产。为了安慰这些人，他们的生活应该被大量的娱乐活动(比如网络，电视和游戏)填满。社会动荡的主要因素之一是阶层之间的利益冲突。那要如何避免少数得益者与大多数的底层人民间的冲突呢？方法之一是给其“奶头”，转移其注意力和不满情绪，让他们更能接受自己的境遇。可以通过观察社会现象而窥探一二，主要表现在媒体的泛娱乐化，大众对于娱乐和游戏产业的高度关注和追随等。——摘自维基百科 如果你看过前段时间上映的斯皮尔伯格导演的《头号玩家》，这部影片除了让我叹为观止、数之不尽的彩蛋之外，还有一个让我细思恐极的地方。这个世界里的大部分人们都不工作，尤其是主角所在的贫民窟，大家都沉溺于一款叫做「绿洲」的游戏，近乎全能的「绿洲」能满足人们各种各样的欲望。大部分的人类不去工作生产，社会如何运转？政府为何不去监管这款游戏？这部电影所处的背景是未来生产力十分发达以及贫富差异极大的社会，我猜测「绿洲」就是用来满足、用来安慰那部分不用积极生产的人们的「奶头」，它是维持社会正常运转的重要因素之一。 当然了，将张一鸣的「及时满足产品」和「绿洲」做类比甚是夸张，有些过于阴谋论了。但是，我们应当保持谨慎，时常审视自己，至少像张一鸣自己那样，信奉「延迟满足」。","categories":[{"name":"emmm","slug":"emmm","permalink":"https://qiantao94.github.io/categories/emmm/"}],"tags":[]},{"title":"读《软技能》","slug":"soft-skills-reading-notes","date":"2018-06-23T07:06:06.000Z","updated":"2019-07-24T02:05:09.055Z","comments":true,"path":"2018/06/23/soft-skills-reading-notes/","link":"","permalink":"https://qiantao94.github.io/2018/06/23/soft-skills-reading-notes/","excerpt":"","text":"副标题：代码之外的生存指南 初识这本书的缘由是在少数派上面看到的一篇关于生产力的文章：软技能—一本写给程序员的生存指南，于是对这本书产生了极大的兴趣。恰逢自己加入了一个半月读的一个读书小组，所以就把这本书列入自己的 15 天读书计划。 通读下来，这本书更像是一本工具书，不会和你说很多的理论知识以及目标原则。就像是这本书的副标题，这是一本「指南」，它以人（而非技术也非管理）为本，为你的自身发展提供了各个方面的行动清单，包括了职业、自我营销、学习、生产力、理财、健身、精神等七个方面的「软技能」。这七个方面就是七章，每一章的内容都不少，由于都是干货，这篇读书笔记并不想、也不能一一复述，我会尽量讲解出这本书的整个结构。 职业软件开发人员需要主动规划自己的职业生涯，你的工作是公司的，但是你的职业生涯却是自己的（这句话不只是适用于软件开发领域的从业人员）。所需要做的第一步就是转变自己的心态，我们需要拥有商业心态。虽以写代码为生，但是本质上古时铁匠铺的铁匠一样没什么差别，虽然为公司工作，但是技能和生意都是自己的。一旦拥有了这样的商业心态，你就可以把自己当作企业来思考。类比「作为企业我能提供什么？」，那么「作为软件开发人员，我能提供什么？」，如此这般，就把自己推向了营销，关于自我营销，是这本书第二篇着重讲解的内容。把你的职业当做企业，将会影响你的： 工作方式 处理自己的财务方式 寻求新工作或新客户的方式 目标给自己设定计划，是个老生常谈的话题了，如何给自己设定目标、如何执行自己的目标以及如何追踪自己的目标，作者的提供的原则和《暗时间》这本书中所提到的是一致的，那就是定大目标，再拆分成小目标，每完成一个小目标，你都能感知到整个大目标的进度，还能适时调整。 人际关系程序员不是只需要和计算机打交道就够了，其实大部分情况都是需要和人打交道的。除了需要处理好自己的社交圈，在工作上难免也会遇到「办公室政治」这样的难题（不能完全避免政治，但要对其保持警惕）。 价值《黑客与画家》一书中指出对员工的价值衡量在于「可测量性」以及「可放大性」，也就是完成一件什么工作、完成的这件工作所带来的后续影响，决定员工价值的高低往往在于后者，也就是「可放大性」，可放大性越高往往风险越高，这和我们所理解的「风险和收益是成正比」的核心是一致的。可放大性放在工作中就是意味着你需要承担多大多少的职责。这鼓励我们需要思考自己在当前岗位上，承担了多少、什么样的职责，并且我们不能畏惧承担高风险的职责，这往往是你价值所能体现的地方。当然了，我们也需要思考当前自己的「曝光度」如何，表现突出并没有错，他也是一个人能力的体现。币圈割韭菜大佬李笑来曾说过：“我知道所知道的和别人知道我所知道的并不一致”，让这两者保持一致的方法就是提高自己的「曝光度」。 关于面试通过面试最快捷的方式就是：在面试之前，你的面试官就已经认识你了。类似于“我读过你的博客”、“我看过你写的书”这样的场景。就是需要在面试之前，你已经进行了成功的自我营销。 自我营销自我营销可不仅仅意味着上面所说到的能帮助你快速通过面试，他也是大范围的提高自己的「曝光度」。 对于有才华的人来说，营销就是一个「乘数效应」——你的营销越好，你的才华才能表现得越发淋漓极致。 如何进行自我营销，作者给软件开发人员提供了这么几个思路： 写博客，博客是推销自己的一种即廉价又简单的方式。 善用社交媒体，社交媒体是自我宣传的工具。 做演讲、报告和培训。 著书立说，吸引追随者。 作者给每种方式都提供了可实操的步骤和方法，比如如何搭建一个属于自己的博客、如何联系出版社以及如何寻找可以演讲的机会（演讲这个不太适用于国内，但是大体的原则是一样的） 学习作者在这一篇提出了自己独到的「十步学习法」，由于作者已经成功的进行了自我营销，有很多追随者，所以这种学习方法能够得以传播并且成功帮助到了很多人。 十步学习法 了解全局。类比一本书之前要看整本书的目录，你要做的就是了解自己学习的主题的全局，做宏观上的了解。 确定范围。对全局有了大概的了解之后，这一步就是确定自己的学习范围。 定义目标。明确「成功」的含义，如果不知道成功是什么样子，很难找准目标，也很难知道自己什么时候已经真正达到目标。 寻找资源。与头脑风暴类似，找到尽可能多的与自己学习主题相关的资料，稍后再进行过滤、去伪存真。 创建学习计划。打造自己的学习计划，一个好方法就是观察别人是如何教你感兴趣的主题的。 筛选资源。根据第 4 步寻找的资源以及第 5 步的学习计划，来对寻找到的资源进行筛选。 开始学习，浅尝辄止。快速学习基础知识，立刻开始实际操作。既要避免盲目开始、行动太快，更要避免准备过多、行动太晚。 动手操作，边学边玩。敢于在学习中进行尝试和探索，但也要把握好边际。 全面掌握，学以致用。深入学习，解决之前遇到没有解决的问题，但依然没有必要把所有资料都看一遍，也需要和第 3 步所定义的目标关联起来。 乐为人师，融会贯通。其实这就是教学相长的过程。 这个方法的形式是次要的，重要的是背后的理念。 消除自己的短板 我们总是倾向于掩饰自己的短板，而且我们也总是太忙，忙到无暇去填补它们。结果，我们要么不能真正明白自己在做什么，要么为了避开自己的短板而采取低效的方法。 知识的短板会阻碍自己的进步，那么如何发现它们呢？ 耗费大量的时间。知识的短板会使工作速度放缓，额外需要大量的时间完成。 重复性的工作也是如此。 未知清单。时刻维护一份清单，坦诚地列出自己不理解或不清楚的事物，并且追踪有哪些主题不断的出现在这份清单上（有利于发现自己不擅长的领域）。 生产力生产力这个话题约等于工作效率，如何提高工作效率又可以这样展开来说： 如何专注？创造不被干扰的环境，如主动给手机开启「勿扰模式」，可能你还需要辅以科学的工作方法来提高你的专注力，如「番茄工作法」。 如何计划自己的工作和学习？作者用「看板」类的软件给自己定季度、月、周以及日计划，再通过「番茄工作法」来进行每日任务的完成。 责任感。对自己负责，提高自己的责任感，因为责任感这种内部动机要比外部动机有效的多/ 避免多任务执行。多任务执行的情况下，时间大多都是浪费在任务切换中，真正的多任务执行应该是将一个不费脑力的任务和一个需要集中注意力的任务结合在一起，比如说一边跑步，一边听书。 职业倦怠？提高生产力的最大障碍之一就是身体和心理上的倦怠，遇到这种倦怠是很正常的，它就像是一堵墙挡在我们和目标之间。穿过这堵墙，需要我们自我激励，并且在任务进行的一开始就要进行约束和规定。 时间杀手作者列举了身边的各种时间黑洞（工作中不知不觉中被浪费掉的那部分时间）以及各种时间杀手： 电视 社交媒体 电子游戏 要我说，在目前，对于国内，最大的时间杀手莫过于短视频了，相比于上面所列到的那些时间杀手，它更让人快速产生愉悦感（成瘾），并且几乎没有操作成本（也就是方便，一点点的碎片时间都能操作）。这就要命了，它不仅是时间杀手，也是时间黑洞。 值得一提的是，作者并没有说禁止看电视玩游戏，而是当我有工作、任务需要完成的时候，我就不能看电视玩游戏，我不能用看电视玩游戏来逃避自己实际应该完成的工作。作者列举了一个十分实用的方法，比如看电视，作者也追剧，但他不每周都去追更，而是等这部剧播完以后，挑个时间一起看完。这样就是化被动为主动，主动掌握并支配自己的时间。 理财印象最深刻的就是作者前前后后投资了大量的房地产，作者并没有专门去炒房，而是边工作边进行各种房地产的交易。我不是震惊他的房产之多，而是震惊他能把自己的工作做好的同时，又能花大量的时间和精力去四处奔走来完成房产的规划与交易，这大概就是因为他能贯彻并执行了前面所说的那么多内容。 除此以外，作者还提倡每个人都要拥有资产与负债的概念，哪些东西是自己的资产，哪些东西是自己的负债，一旦你理清楚并拥有这样的观念的话，在如何花钱这件事情上，你的思维就是长期而不是短期的了。 在这一篇的内容中，我还被普及了「期权」的概念，作者的解释生动形象。 健身很难想象，作为一个软件开发人员，作者之前还做过模特，还参加过健身大赛并取得很好的名次，人生经历不可不谓之丰富。这一篇就是普及健身的理念，健身分为两个阶段，一是减脂，二是增肌。说实话，我被打动了，已经开始按照他所说的方法和理论来控制饮食以及锻炼进行减脂！！！ 精神我们需要拥有正确的心态，因为谁都知道心态正确对自己对他人有极大的意义，如何做？ 改变自己的想法。 冥想 劳逸结合 多看书 我们也需要给自己构建一个积极的自我形象，相当于是对自己的一个激励的手段。 一旦你在自己的脑海中设立了这样的形象，接下来的任务就是开始执行“仿佛”模式。“仿佛”你已经变成了你想变成的那个人。无论是言行举止，还是穿着打扮，都像你想成为的那个人一样，甚至像你想成为的那个人一样刷牙。不要太关注现实是怎么样的，不要太在意别人如何议论你的“变化”；相反，假装你已经达到了你想要的目标，你的新行为只是这个新个性的自然延伸。 以上一般的畅销书，你看完以后你似乎知道一些目标和理论，但是无奈并不知道如何去实现目标、应用理论，这样反而会徒增焦虑。而这本书，就像我一开头所说的那样，你可以把它当做工具书来看，它的实操性很强（说实话，有些方法还需要因地制宜，比如房地产相关的），它会减轻你的焦虑。","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://qiantao94.github.io/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://qiantao94.github.io/tags/读书笔记/"}]},{"title":"读《暗时间》","slug":"anshijian-reading-notes","date":"2018-06-16T15:37:27.000Z","updated":"2019-07-24T02:07:25.945Z","comments":true,"path":"2018/06/16/anshijian-reading-notes/","link":"","permalink":"https://qiantao94.github.io/2018/06/16/anshijian-reading-notes/","excerpt":"","text":"你的认知水平，决定了你的个人的天花板，而认知本身，也是存在天花板的。如何提高自己的认知水平呢？那就是要多读经典书籍，尤其是多读经典的心理学著作，因为它们能够帮助你更好的认识自己、更清楚的了解这个世界。 这是我读完这本书后最大的感受。当我翻开第一章的时候，我就清楚的认识到了自己的不足了，并且为自己扼腕叹息，如果能够早点读到这本书的话，那么或许在个人心智模式的自己探索之旅中，会少走很多弯路。我倾佩作者的阅读量之广、思维能力之强，作者将八年博客的内容精选，著成了这本书，为我打开了心理学的大门。 什么是暗时间？对于时间，我们可能都会存在错觉，认为时间对每个人都是均等的，其实不然。如果你正在学习一门专业，你可以「投入」很多时间，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。「投入时间」的说法是错误的，应该是「投入的时间和效率的乘积」。作者也是一名程序员，他将人脑和计算机作了类似的对比：你的 CPU 是满载的，你投入的时间就等于了实际流逝的时间。 看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的「暗时间」，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为「暗时间」，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。 能够充分利用「暗时间」的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。 专注专注就是一种忘记时间流逝的“沉浸”状态（心理学上叫做“流体验”），大脑中所有相关的记忆神经网络都被激活了，这个不是三两分钟的事情。而一旦这种状态被破坏，无形间效率就会大打折扣。 避免多任务切换。程序员们都知道，任务切换需要耗费许多额外的花销，通俗地来讲，首先需要保存当前上下文以便下次能够顺利切换回来，然后要加载目标任务的上下文。如果一个系统不停地在多个任务之间来回倒腾，就会耗费大量的时间在上下文切换上，无形中浪费很多的时间。 不仅如此，大脑开始一件任务的时间必须需要一定的时间来「热身」—— 需要一定时间来进入专注的工作或学习的状态，这个时间因人而异，可以通过练习来改变。 举个例子：你写代码写得正 high，忽然被叫去开了一通会，写到一半的代码搁在那儿。等你开完会回来你需要多久能够重新进入状态？又或者，你正在调 bug，你已经花了二十分钟的时间把与这个 bug 可能相关的代码前前后后都理解了一遍，心中构建了一个大致的地图，就在这时，呃，你又被叫去开了个会(:D)，开完会回来，可想而知，得花上一些时间来回想一下刚刚弄清的东西了。 上面的例子在工作生活中是无法避免的，工作中需要处理的事情很多，导致时不时需要在多个任务之间切换；另一方面，即便能够把任务的优先级分配得比较合理，也难免在做一件事情的时候心中忽然想起另一件事还没做的焦虑来，因为没做完的事情会在大脑中留下一个「隐藏的进程」，时不时地发个消息提醒你一下，中断你正在做的事情。所以需要抗干扰能力， 如何锻炼专注和抗干扰能力？在干扰的环境中看书。另外经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。 设计你的进度条进度条的设计同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。 设计自己的进度条做事情也是同样的道理，善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。时间管理中有一个 GTD 方法学，其核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——「完成」和「未完成」，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是「未完成」，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的。 不要过早退出循环我们都在 for 循环，区别在于你是什么情况下 break 的。有的人退出阈值高，这是能坚持的一类人，有的人退出阈值低，这类人很可能遇到一些障碍就退出了。过早退出的原因往往在于对于未来的不确定性，对于投资时间最终无法收到回报的恐惧，感受到的困难越大，这种恐惧越大，因为越大的困难往往暗示着这个任务需要投资的时间越大。所以其实我们都是直觉经济学家，当我们说「畏难」的时候，其实我们畏惧的不是困难本身，而是困难所暗示的时间经济学意义。 选择的悖论如果你有一些钱不知道花在A还是B上，你先不作决定，没问题，因为钱还是你的，但如果你有一些时间，不知道花在A上还是B上，不行，因为过了这段时间，这段时间就不是你的了。这个道理也许能对拖延症晚期的你有所帮助。 如何有效的记忆和学习记忆机制我们在记忆的时候将许多线索（例如当时的场景、问题的背景，甚至所处的语言环境、空间位置）一并编码进了记忆，事后能否提取出这段记忆严重取决于提取线索是否丰富、以及在回忆的时候是否重现了记忆时的线索。 实践方法养成习惯经常主动回顾一段时间学到的东西（老生长谈了）：这不仅有利于巩固长时记忆，而且一段时间之后的回顾你可能已经因为新的知识学习从而对原先的认识有了进一步的看法，通过回顾，可以整合新旧知识，得到新的启发。（艾宾浩斯遗忘曲线） 创造回忆的机会第一条很少有人能坚持，所以有了这一条 经常与别人讨论 整理笔记——良好分类的信息更容易提取 书写——书写是更好的思考 设身处地地「虚拟经历」别人经历过的事情很多时候你也无法真正遍历每条人生路径看看会发生什么，你没有这样的时间资源，取而代之的是你只能通过别人的“替代经验”，自己的“虚拟经历”，来获得尽量多的信息 抽象和推广因为如果一件事情就是一件事情，那么我们永远也无法学习到“未来”的知识，结果就是每堵墙都要去自己撞一遍试试硬度。 我们对心理学存在的误解 提到心理学，很多人脑海中的第一印象就是“心理问题”、“心理咨询”、“弗洛伊德”，“抑郁症”、“读心术”这些字眼，总觉得关心心理学的都是一些心理阴暗或有问题的家伙，这是对现代心理学典型的误解。 不得不承认，普罗大众对心理学的印象就是如此。而稍微接触心理学领域的人谈及心理学，则肯定会谈及「弗洛伊德」，毕竟他的《梦的解析》影响太大了。真正的现代心理学是什么呢？它是跨学科研究人脑思维的特点以及和现实生活的关系，简而言之，就是帮助你去了解你的大脑，帮助你去更好的利用你的大脑。 与我们的直觉相反，我们大脑的思维存在着各种各样的缺陷和陷阱，我们解决日常问题的思维方式也并不总是最优的，我们感觉正确的事情有很多是错的，我们习以为常的天经地义的行为也未必就是合乎效益最大化原则的。不用怀疑，这些都是正常的，毕竟我们的大脑从远古时代进化而来的，存在着一些原始的情感和条件反射模块，它们是为了能够在远古时代生存并繁衍而产生的，显然这些历史遗留的思维规律并不适应我们目前的现代社会。举一个最简单的例子：我们的祖先在远古时代由于资源的匮乏，时常挨饿，所以原始大脑已经形成了相应的条件反射模块，时不时的提醒你囤积你目前不需要的能量。所以说减肥就变得异常困难。 上面所说的这个原始的情感和条件反射模块，它就是我们的「原始大脑」的一部分。然而我们同样拥有着一个「理性大脑」，它拥有着我们人类的高级认知模块，在人类的历史长河中，它们是在相对较近的进化年代才出现的。「原始大脑」和「理性」大脑并不总是合作无间的。所以很多决策的场合中，我们脑海中总会有两个声音在互相博弈，让我们在作出决定时犹豫不决。而「原始大脑」在千万年的进化长河中忠实地保护着我们在自然环境中生存下来并努力繁衍后代，这些模块似乎理应拥有更强大的力量，于是可能很不幸决定权就交给了「原始大脑」，所以我们总能作出事后懊悔的决定。 如何让「理性大脑」在决策的时候占决策权，而不是「原始大脑」？经常动用理性思考也能够锻炼理性大脑的“实力”，在更多的决策场合获得压倒性优势。 逃出你的肖申克我们每个人都有一座自己的肖申克，也就是自己的思维监牢。比如说，为什么很多事情，我们一定要亲身经历才能明白呢？作者从心理学方面道出了以下几个缘由： 切身体验亲身经历一个负性事件带来的情绪记忆要比看着或听说别人遭受一个同样的事件所感受到的强烈得多，形成的负性条件反射也远远更持久。我们一定程度上的确能够感同身受，但心理学实验同样也表明，自己是无法从强度上真正感同身受别人的痛苦的。 别人的道理，自己的事情别人在告诉你一个道理的时候往往只能告诉你怎么(how)做，而难以说清为什么(why)要。 朋友给出的道理或故事总是跟他当初经历的情境细节有着千丝万缕的联系，你记下了朋友的道理和故事，同时也就将这个道理和他当时经历的情境线索给挂钩起来了，于是当类似的情境发生的时候，你的记忆系统就能够根据情境线索提取出朋友当时说给你听的那些道理（《找寻逝去的自我》）；然而，这种记忆提取机制同时也有他的弱点，那就是当你经历的情境跟朋友当初经历的情境相似性不足（尽管抽象到本质上可能是一回事）的话，你就不会想起他曾经说的那些道理。这就是很多时候我们发现自己道理是听了一堆，结果自己生活中却不会用的原因。 世界是复杂的，未来是不确定的 人们根本无法确切地向你保证A选项一定优于B选项：比如，好好学习并不一定会有好的前程；不好好学习也并不一定以后就一塌糊涂。 人类天生有一种寻求确定性的需要，以及控制周遭的小世界的需求。我们总是希望听到“你只要这样这样，以后就一定能够那样那样”这类令人安心的话。然而与我们的控制错觉相反，这个世界有太多因素是不确定的，除了自己的因素比较可控之外，外界的机遇因素几乎完全不是能够控制或预测的。 认知失调与自我辩护如果我们在听到别人的道理之前已经有了一个心理上的倾向，那么即便别人给出一个有一定说服力的理由，根据认知失调理论，我们也会竭力为自己辩护；又由于世界是复杂的，所以我们几乎总是能够找到辩护的借口——“上次报纸上说一个英国老太太每天必吸一支烟，活了一百多岁呢。” 失败即成功有时候，我们的确需要在撞南墙的过程中总结出经验教训（特别是对于尚未有人走过的路），并到达成功的彼岸。 情绪对照经历了失败之后，我们在做「正确」的事情的时候便会觉得更理直气壮。如果没有经历失败后的糟糕记忆，我们就算理性地认识到目前的做法是更合适的，也很难从情绪上强烈地感受到这么做的「正确感」。 天性如前面所说的「原始大脑」和「理性大脑」。 不可替代性和核心竞争力什么才是你的不可替代性以及核心竞争力呢？有如下几点： 专业领域技能成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。 跨领域的技能解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind。 学习能力严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。 性格要素严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等。 锤子与钉子（鱼是最后一个看到水的）如果你手里有一把锤子，所有东西看上去都像钉子。 即之所以所有东西看起来都像钉子，是因为人倾向于在既有框架下去解决问题；更重要的是，在这个过程中很难觉察到框架约束的存在，正如鱼觉察不到水的存在一样。这是作为技术人常常会犯的错误。 心中有锤，就容易为其奴役：在遇到问题的时候不是具体问题具体分析，而是屁股决定脑袋，不管三七二十一先上黄金大锤再说，而且往往还颇有成就感，却将自己真正原本要解决的问题抛在脑后了。始终莫要忘记提醒自己，“问题是什么？” 但毫无疑问，没有锤子是万万不行的，没有谁会傻到徒手钉钉。重点是选择合适你的工具。这又要求在学习工具的时候始终别忘记它的适用范围。 如果你想钉一个钉子，所有东西看上去都像是锤子。如果你心中专注于你想要解决的问题，那么你所看到的东西就会呈现出以往你没有看到的一面。 举个例子：阿基米德洗了一辈子的澡，然而，只有那一次，当他想要解决皇冠密度问题的时候，想到可以利用排水体积来测量不规则物体体积。 最后除了以上的关于时间管理和心理学方面的内容，这本书还讲述了作者本人在其母校南大的七年生活经历中的心路历程，以及一些他的学习方法和学习习惯，非常值得你去书中阅读。除此以外，作者还在书的后篇，花了很大的篇幅来介绍算法，包括「算法为什么这么难」、「如何去学习算法」以及「算法与数学」等知识。算法也一直是我的弱项，这后篇的内容我还是需要二次研读的。 本书链接","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://qiantao94.github.io/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://qiantao94.github.io/tags/读书笔记/"}]},{"title":"以乞讨为生","slug":"emmm/live-by-begging","date":"2018-06-09T01:00:00.000Z","updated":"2019-09-08T10:16:12.891Z","comments":true,"path":"2018/06/09/emmm/live-by-begging/","link":"","permalink":"https://qiantao94.github.io/2018/06/09/emmm/live-by-begging/","excerpt":"\b以前，我是不讨厌这些乞讨的，不，应该说，我会同情他们。","text":"\b以前，我是不讨厌这些乞讨的，不，应该说，我会同情他们。世上为何有这样的一群人，他们无家可归，靠别人的施舍才能生存下来？我记得当我这样开始可怜他们的时候，我的同情心就会泛滥一地。你看那个小屁孩，给乞丐施舍仅有的一块钱硬币的时候，还问他够不够。都说人性本善，如果善良可以用度量的话，那么我的天赋树上的善良值，相较于他人，便多加了几点。 现在呢，地铁上我遇到的每个乞丐，都会让我嗤之以鼻。我也在想，我是如何被改变的，我是何时被改变的。 还记得，在高碑店上班的时候，挤早高峰的八通线，上车和下车都是一件麻烦又痛苦的事情。列车一到站，我便用力逃离车厢，然后又被人流，推入地下通道。临近通道出口处，有一老头端坐，拉着二胡。他戴着茶色墨镜，他的上衣和他的头发一样白，虽已入秋，却是一件单薄的长衫。来不及驻足聆听，我继续往前走着，二胡声渐渐稀疏着，直到我走出了地下通道，这二胡就完全被出口处煎饼摊的人群声以及从那条每天早上都会堵的水泄不通的路上传来此起彼伏的鸣笛声给淹没了。终于有一天，我像往常一样又钻进了那条地下通道，与往常不一样的是，隔着人流的我一听到二胡声，就从背包里，掏出了那张绿色的一块钱纸币，在经过那个老头的时候，放进了他那黑色的琴盒里。他说“谢谢”，但并没有停下拉弦。我也不知道为什么，也许只是觉得他拉的《女儿情》好听罢了。 你乘坐北京的地铁，会发现地铁广播不仅用来报站，它还用来呼吁大家「共同抵制乞讨卖艺等行为」。然而有一天我第一次从一号线换乘四号线，指示牌下来往的人流被一堵墙分隔开，而那堵墙根下，坐着一个瘦骨嶙峋的老头，很明显并没有工作人员驱赶他。说不上是一种乞讨，来往的人潮涌动，他就坐在他们中间，在大夏天里敞开上衣，手里和眼里只有自己脚边装空塑料瓶的袋子，就好像他并不期望经过的某个人会投下一份同情。 时间再往前，那时刚来北京没多久，和朋友们走在夜里的工体东路。我们在一卖唱的面前驻足停留，那人自弹自唱，音响麦克风一应俱全，在我们听完了后半首李志的《忽然》后，其中一位大学里搞乐队的朋友说：“其实，我挺喜欢这样的，拿着一把吉他四处流浪”，我心想：“你扯淡呢，人家职业卖唱都不一定每天能在这城市吃饱饭，你能比吗？还四处流浪，不怕流落街头吗？太理想了。” 来到这个城市已有 952 天，我也再没有去过工体东路，也很久没在一号线和四号线之间换乘，更别说乘坐八通线去高碑店了。我和他们其实并无二致，用自己的方式在这个城市讨生活。而地铁上的这些乞丐，其实也是这样的，只不过这群人选择了一种让我厌恶的方式，他们使用精心的伪装来博取你的同情，他们努力地吸引你的注意力，从而让你忽视真正那些需要帮助的人，同情和善良的品质随之变得廉价。 后来的某天，我坐在夜里十一点半以后的麦当劳里，遇到了另一群人。这些人有的神情异常，嘴里絮絮叨叨的；有的四处张望，估摸着能否吃上哪一桌剩下的食物；而有的早已蜷缩在角落的座椅上，开始了一天中安静的睡梦。这些人或许曾经挣扎过，但已失去了生存技能，他们没得选择，城市基础设施建设的欠缺，使得麦当劳这样 24 小时营业的场所成了他们夜晚唯一的归宿。 他们的存在并没有改变我的选择，也更没有影响我生活的轨迹。终将有一天，他们会被我遗忘、被其他人遗忘、被自己遗忘，而我，也会像他们一样。","categories":[{"name":"emmm","slug":"emmm","permalink":"https://qiantao94.github.io/categories/emmm/"}],"tags":[]},{"title":"2018 年书单","slug":"book-list-2018","date":"2018-01-30T09:09:08.000Z","updated":"2018-06-13T13:24:21.595Z","comments":true,"path":"2018/01/30/book-list-2018/","link":"","permalink":"https://qiantao94.github.io/2018/01/30/book-list-2018/","excerpt":"1\b 本书 / 月","text":"1\b 本书 / 月 《知行合一 王阳明》 “传记类，主要介绍王阳明及其心学的发展历程。全书已读 36% ” 《深入理解Java虚拟机》 “技术类，JVM 相关知识。全书已读 12% ” 《只是为了好玩》 “传记类，Linux 之父 Linus” 《图解HTTP》 “技术类，通俗易懂的 HTTP 知识” 《基地》 “小说类，科幻小说，基地三部曲第一部” 《图解TCP/IP》 “技术类，通俗易懂的 TCP/IP 知识” 《基地与帝国》 “小说类，科幻小说，基地三部曲第二部” 《Android 开发艺术探索》 “技术类，全书已读 36% ” 《第二基地》 “小说类，科幻小说，基地三部曲第三部” 《图解密码技术》 “技术类，密码学入门书籍” 《上帝的图书馆》 “小说类，奇幻小说” 《函数式编程思维》 “技术类，本书脱离特定的语言特性，关注各种 OOP 语言的共同实践做法，展示如何通过函数式语言解决问题”","categories":[],"tags":[{"name":"书单","slug":"书单","permalink":"https://qiantao94.github.io/tags/书单/"}]},{"title":"去除 VSCode 上 Solarized Dark 主题的关键字加粗","slug":"solarized-dark-no-bold","date":"2018-01-16T09:28:49.000Z","updated":"2019-07-24T02:05:11.628Z","comments":true,"path":"2018/01/16/solarized-dark-no-bold/","link":"","permalink":"https://qiantao94.github.io/2018/01/16/solarized-dark-no-bold/","excerpt":"","text":"Solarized 是一套非常优秀的主题配色，几乎在所有的编辑器上都能看到它的身影，它包括两种配色，亮色 (light) 以及 暗色 (dark)。 不加粗VSCode 本身自带 Solarized 系列主题，表现几乎完美，只有有一点一直不能习惯，就是它将代码中的关键字、修饰符进行了加粗。于是我尝试寻找解决方案，在扩展商店里搜索「no-bold」，惊喜的发现 solarized-light-no-bold 这个主题，原来同样也有人不喜欢加粗，但是这哥们只改了 light 配色，没改 dark 配色。于是我仿照 light，solarized-dark-no-bold 诞生了。 使用点击链接安装，或者，在扩展商店里搜索：solarized-dark-no-bold 即可！","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://qiantao94.github.io/tags/VSCode/"},{"name":"插件","slug":"插件","permalink":"https://qiantao94.github.io/tags/插件/"}]},{"title":"生成随机字符的 Android Proguard 混淆字典","slug":"Generate-Android-proguard-dictionary","date":"2018-01-04T08:24:55.000Z","updated":"2019-07-24T02:06:38.226Z","comments":true,"path":"2018/01/04/Generate-Android-proguard-dictionary/","link":"","permalink":"https://qiantao94.github.io/2018/01/04/Generate-Android-proguard-dictionary/","excerpt":"只是一个简易的 Python 脚本","text":"只是一个简易的 Python 脚本Android 中使用 Proguard 进行混淆后，代码中的类名、方法名、变量名会变成诸如 a b c 这样的字符。其实我们可以指定混淆后使用哪些字符代替显示，也就是在 proguard-rules.pro 中可以这样配置： -obfuscationdictionary 字典文件-classobfuscationdictionary 字典文件-packageobfuscationdictionary 字典文件 而这里的字典文件就是一个类似于这样的文本文件： #混淆字典goO1VUVN0fvVHTAUKdSX 上面的字典中的字符，是从大小写字母以及数字中随机抽取的。如果你也有这样的需求，你可以使用我的 Python 脚本： import stringimport randomdef rand_string(length): return ''.join(random.choice( string.ascii_lowercase + string.ascii_uppercase + string.digits) for i in range(length) )if __name__ == '__main__': FILE = open(\"proguard-dictionary.txt\", 'w') WORD_LINES = 40 FILE.write(\"#proguard dictionary\\n\\n\") for i in range(1, WORD_LINES): FILE.write(rand_string(2)+\"\\n\") FILE.close() 希望你使用愉快 🙂","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"Python","slug":"Python","permalink":"https://qiantao94.github.io/tags/Python/"},{"name":"Proguard","slug":"Proguard","permalink":"https://qiantao94.github.io/tags/Proguard/"}]},{"title":"QQ 6.x 抽屉菜单","slug":"自定义控件？试试300行代码实现QQ侧滑菜单","date":"2017-01-16T11:36:01.000Z","updated":"2019-07-24T02:07:55.197Z","comments":true,"path":"2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/","link":"","permalink":"https://qiantao94.github.io/2017/01/16/自定义控件？试试300行代码实现QQ侧滑菜单/","excerpt":"可以说是 ViewDragHelper 的最佳实践","text":"可以说是 ViewDragHelper 的最佳实践Android 自定义控件并没有什么捷径可走，需要不断得模仿练习才能出师。这其中进行模仿练习的 demo 的选择是至关重要的，最优选择莫过于官方的控件了，但是官方控件动辄就是几千行代码往往可能容易让人望而却步。本文介绍如何理解并实现 Android 端的 QQ 抽屉菜单。首先上完成的效果图： 首先本文并不会长篇大论的讲解自定义控件所需要的从绘图、屏幕坐标系、滑动到动画等原理，因为我相信无论你是否会自定义控件，这些原理你都已经从别处烂熟于心了。但是为了方便理解，会在实现的过程中进行穿插讲解。 确定目标及方向动手撸代码前，我们看一眼这个效果。首先确定我们的目标是需要自定义一个 ViewGroup，需要控制它的两个子 View 进行滑动变换。进一步观察我们可以发现两个子 View 是叠加再一起的，所以为了减少代码我们可以考虑直接继承于 ViewGroup 的一个实现类：FrameLayout。底层的是菜单视图menu，叠加在上面的是主界面 main。新建一个类：CoordinatorMenu，并在加载布局后拿到两个子 Viewpublic class CoordinatorMenu extends FrameLayout &#123; private View mMenuView; private View mMainView; //加载完布局文件后调用 @Override protected void onFinishInflate() &#123; mMenuView = getChildAt(0);//第一个子 View 在底层，作为 menu mMainView = getChildAt(1);//第二个子 View 在上层，作为 main &#125; 为滑动做准备实现手指跟随滑动，这其中有很多方法，最基本的莫过于重写 onTouchEvent 方法并配合 Scroller 实现了，但是这也是最复杂的了。还好官方提供了一个 ViewDragHelper 类帮助我们去实现（本质上还是使用Scroller）。在我们的构造方法中通过 ViewDragHelper 静态方法进行其初始化：mViewDragHelper = ViewDragHelper.create( this, TOUCH_SLOP_SENSITIVITY, new CoordinatorCallback()); 三个参数的含义： 需要监听的 View，这里就是当前的控件 开始触摸滑动的敏感度，值越大越敏感，1.0f 是正常值 一个 Callback 回调，整个 ViewDragHelper 的核心逻辑所在，这里自定义了一个它的实现类 然后拦截触摸事件，交给我们的主角 ViewDragHelper 处理：@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //将触摸事件传递给 ViewDragHelper，此操作必不可少 mViewDragHelper.processTouchEvent(event); return true;&#125; 处理 computeScroll 方法：//滑动过程中调用@Overridepublic void computeScroll() &#123; if (mViewDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this);//处理刷新，实现平滑移动 &#125;&#125; 处理部分Callback回调//告诉 ViewDragHelper 对哪个子 View 进行拖动滑动@Overridepublic boolean tryCaptureView(View child, int pointerId) &#123; //侧滑菜单默认是关闭的 //用户必定只能先触摸的到上层的主界面 return mMainView == child;&#125;//进行水平方向滑动@Overridepublic int clampViewPositionHorizontal(View child, int left, int dx) &#123; return left;//通常返回 left 即可，left 指代此 view 的左边缘的位置&#125; main 的滑动这样我们就能在水平方向上随意拖动上层的子 View – main 了，接下来就是限制它水平滑动的范围了，范围如下图所示： 改写上面的水平滑动方法，@Overridepublic int clampViewPositionHorizontal(View child, int left, int dx) &#123; if (left &lt; 0) &#123; left = 0;//初始位置是屏幕的左边缘 &#125; else if (left &gt; mMenuWidth) &#123; left = mMenuWidth;//最远的距离就是菜单栏完全展开后的 menu 的宽度 &#125; return left; &#125; 增加回弹效果： 当菜单关闭，从左向右滑动 main 的时候，小于一定距离松开手，需要让它回弹到最左边，否则直接打开菜单 当菜单完全打开，从右向左滑动 main 的时候，小于一定距离松开手，需要让它回弹到最右边，否则直接关闭菜单 首先判断滑动的方向：//当 view 位置改变时调用，也就是拖动的时候@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; //dx 代表距离上一个滑动时间间隔后的滑动距离 if (dx &gt; 0) &#123;//正 mDragOrientation = LEFT_TO_RIGHT;//从左往右 &#125; else if (dx &lt; 0) &#123;//负 mDragOrientation = RIGHT_TO_LEFT;//从右往左 &#125;&#125; 在松开手后：//View 释放后调用@Overridepublic void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); if (mDragOrientation == LEFT_TO_RIGHT) &#123;//从左向右滑 if (mMainView.getLeft() &lt; mSpringBackDistance) &#123;//小于设定的距离 closeMenu();//关闭菜单 &#125; else &#123; openMenu();//否则打开菜单 &#125; &#125; else if (mDragOrientation == RIGHT_TO_LEFT) &#123;//从右向左滑 if (mMainView.getLeft() &lt; mMenuWidth - mSpringBackDistance)&#123;//小于设定的距离 closeMenu();//关闭菜单 &#125; else &#123; openMenu();//否则打开菜单 &#125; &#125;&#125;public void openMenu() &#123; mViewDragHelper.smoothSlideViewTo(mMainView, mMenuWidth, 0); ViewCompat.postInvalidateOnAnimation(CoordinatorMenu.this);&#125;public void closeMenu() &#123; mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0); ViewCompat.postInvalidateOnAnimation(CoordinatorMenu.this);&#125; menu的滑动展开后，我们就可以触摸到底层的 menu 视图了，我们拽 menu 不能拖动它本身，也不能拖动 main，因为我们在前面指定了触摸只作用于 main。我们可以先思考一下，QQ 的侧滑菜单底层是跟随上层移动的（细心的你会发现不是完全跟随的，它们之间的距离变化有个线性关系，这个稍后再说），这样的话那我们就可以把 menu 完全托付给 main 处理，分两步：1. menu 托付给 main; 2. main 滑动时管理 menu 的滑动。首先我们要先确定 menu 的初始位置及大小，重写 layout 方法，向左偏移一个 mMenuOffset@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); MarginLayoutParams menuParams = (MarginLayoutParams) mMenuView.getLayoutParams(); menuParams.width = mMenuWidth; mMenuView.setLayoutParams(menuParams); mMenuView.layout(-mMenuOffset, top, mMenuWidth - mMenuOffset, bottom); &#125; 我们先实现第一步：触摸到 menu，交给 main 处理。在这之前改写前面的回调方法，让 menu 能接受触摸事件@Overridepublic boolean tryCaptureView(View child, int pointerId) &#123; return mMainView == child || mMenuView == child;&#125; 然后//观察被触摸的 view@Overridepublic void onViewCaptured(View capturedChild, int activePointerId) &#123; if (capturedChild == mMenuView) &#123;//当触摸的 view 是 menu mViewDragHelper.captureChildView(mMainView, activePointerId);//交给 main 处理 &#125;&#125; 在这一步后，我们就可以在手指触摸到 menu 的时候，拖动 main。这个感觉就像是指桑骂槐，指着的是 menu，骂的却是 main，哈哈。 接下来我们实现第二步，menu 跟随 main 滑动先看下面 menu 与 main 的位置关系图 很明显我们能得出一个结论： 从 menu 关闭到 menu 的打开：menu 移动了它的初始向左偏移距离 mMenuOffset，main 移动了的距离正好是 menu 的宽度 mMenuWidth 所以我们就可以用之前用到的回调：onViewPositionChanged(View changedView, int left, int top, int dx, int dy)，因为这里的 dx 正是指代移动距离，只要 main 移动了一个 dx，那我们就可以让 menu 移动一个 dx * mMenuOffset / mMenuWidth，不就行了吗？看起来十分美好，实践起来却是No!No!No!，因为需要对 menu 使用layout 方法进行重新布局以达到移动效果，而这个方法传进去的值是int型，而我们上面的计算公式的结果很明显是个float，况且很不巧的是这个 dx 是指 代表距离上一个滑动时间间隔后的滑动距离，就是把你整个滑动过程分割成很多的小块，每一小块的时间很短，如果你滑动很慢的话，那么在这很短的时间内 dx=1 ，fuxk 。所以这样计算的话精度严重丢失，不能达到同步移动的效果。所以我们只能换一种思维，使用它们之间的另一种关系：menu 左边缘和main 左边缘之间的距离是由 mMenuOffset 增加到 mMenuWidth，此时 main 移动了 mMenuWidth。可以认为这种增加是线性的，如下图所示： 根据图及公式 y = kx + d 得出：mainLeft - menuLeft = (mMenuWidth - mMenuOffset) / mMenuWidth * mainLeft+ mMenuOffset 所以这样重写回调 onViewPositionChanged 即可使 menu 跟随main 进行滑动变换：@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; float scale = (float) (mMenuWidth - mMenuOffset) / (float) mMenuWidth; int menuLeft = left - ((int) (scale * left) + mMenuOffset); mMenuView.layout(menuLeft, mMenuView.getTop(), menuLeft + mMenuWidth, mMenuView.getBottom());&#125; 相信如果我没有给出上面的数学关系解答，直接看代码，你可能会一脸懵逼，这也是很多自定义控件源码难读的原因。 给 main 加个滑动渐变阴影经过上面的操作，感觉总体已经有了模样了，但还缺少一样东西，就是 main 经过菜单由关闭到完全打开的过程中，会有一层透明到不透明变化的阴影，看下面动图演示： 实现这个功能我们需要知道 ViewGroup 通过调用其 drawChild 方法对子 view 按顺序分别进行绘制，所以在绘制完 menu 和 main 后，我们需要绘制一层左边缘随 main 变化且上边缘、右边缘和下边缘不变的视图，而且这个视图的透明度也会变化。@Overrideprotected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; boolean result = super.drawChild(canvas, child, drawingTime);//完成原有的子view：menu和main的绘制 int shadowLeft = mMainView.getLeft();//阴影左边缘位置 final Paint shadowPaint = new Paint();//阴影画笔 shadowPaint.setColor(Color.parseColor(\"#\" + mShadowOpacity + \"777777\"));//给画笔设置透明度变化的颜色 shadowPaint.setStyle(Paint.Style.FILL);//设置画笔类型填充 canvas.drawRect(shadowLeft, 0, mScreenWidth, mScreenHeight, shadowPaint);//画出阴影 return result;&#125; 其中这个 mShadowOpacity 是随 main 的位置变化而变化的：private String mShadowOpacity = \"00\"@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; float showing = (float) (mScreenWidth - left) / (float) mScreenWidth; int hex = 255 - Math.round(showing * 255); if (hex &lt; 16) &#123; mShadowOpacity = \"0\" + Integer.toHexString(hex); &#125; else &#123; mShadowOpacity = Integer.toHexString(hex); &#125;&#125; 至此我们的菜单可以说是完工了，but！ 还需要一些优化1.如果打开菜单，熄屏，再亮屏，此时菜单就又恢复到关闭的状态了，因为重新亮屏后，layout 方法会重新调用，也就是说我们的子 view 会重新布局，所以要改写这个方法：@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); MarginLayoutParams menuParams = (MarginLayoutParams) mMenuView.getLayoutParams(); menuParams.width = mMenuWidth; mMenuView.setLayoutParams(menuParams); if (mMenuState == MENU_OPENED) &#123;//判断菜单的状态为打开的话 //保持打开的位置 mMenuView.layout(0, 0, mMenuWidth, bottom); mMainView.layout(mMenuWidth, 0, mMenuWidth + mScreenWidth, bottom); return; &#125; mMenuView.layout(-mMenuOffset, top, mMenuWidth - mMenuOffset, bottom);&#125;//获取菜单的状态@Overridepublic void computeScroll() &#123; if (mMainView.getLeft() == 0) &#123; mMenuState = MENU_CLOSED; &#125; else if (mMainView.getLeft() == mMenuWidth) &#123; mMenuState = MENU_OPENED; &#125;&#125; 2.旋转屏幕也会出现上述的问题，这时就需要调用 onSaveInstanceState 和 onRestoreInstanceState 这两个方法分别用来保存和恢复我们菜单的状态。protected static class SavedState extends AbsSavedState &#123; int menuState;//记录菜单状态的值 SavedState(Parcel in, ClassLoader loader) &#123; super(in, loader); menuState = in.readInt(); &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; super.writeToParcel(dest, flags); dest.writeInt(menuState); &#125; ... ... ...&#125;@Overrideprotected Parcelable onSaveInstanceState() &#123; final Parcelable superState = super.onSaveInstanceState(); final CoordinatorMenu.SavedState ss = new CoordinatorMenu.SavedState(superState); ss.menuState = mMenuState;//保存状态 return ss;&#125;@Overrideprotected void onRestoreInstanceState(Parcelable state) &#123; if (!(state instanceof CoordinatorMenu.SavedState)) &#123; super.onRestoreInstanceState(state); return; &#125; final CoordinatorMenu.SavedState ss = (CoordinatorMenu.SavedState) state; super.onRestoreInstanceState(ss.getSuperState()); if (ss.menuState == MENU_OPENED) &#123;//读取到的状态是打开的话 openMenu();//打开菜单 &#125;&#125; 2.避免过度绘制。menu 和 main 在滑动过程中会有重叠部分，重叠部分也就是 menu 被遮盖的部分，是不需要再绘制的，我们只需要绘制显示出来的 menu 部分，如图所示： 在 drawChild 方法中增加以下代码 @Overrideprotected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; final int restoreCount = canvas.save();//保存画布当前的剪裁信息 final int height = getHeight(); final int clipLeft = 0; int clipRight = mMainView.getLeft(); if (child == mMenuView) &#123; canvas.clipRect(clipLeft, 0, clipRight, height);//剪裁显示的区域 &#125; boolean result = super.drawChild(canvas, child, drawingTime);//绘制当前 view //恢复画布之前保存的剪裁信息 //以正常绘制之后的 view canvas.restoreToCount(restoreCount);&#125; 写在最后至此，我们的侧滑菜单即实现了功能，又优化并处理了些细节。如果有时候遇到功能不知道怎么实现，其实最好的解决方向就是先看看官方有没有实现过这样的功能，再去他们的源码里寻找答案，比如说我这里实现的阴影绘制以及过度绘制优化都是参照于官方控件 DrawerLayout，阅读官方源码不仅能让你实现功能，还能激发你并改善你的代码质量，会有一种 卧槽，代码原来应该这么写 的感叹。 本文源码地址：https://github.com/bestTao/CoordinatorMenu，有问题欢迎提issue。 你也可以直接在项目中引入这个控件： 先添加以下代码到你项目中的根目录的build.gradle allprojects &#123; repositories &#123; ... maven &#123; url 'https://jitpack.io' &#125; &#125;&#125; 再引入依赖即可： dependencies &#123; compile 'com.github.bestTao:CoordinatorMenu:v1.0.2'&#125; 详细内容及最新版本可以参考 [README.md]","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"自定义控件","slug":"自定义控件","permalink":"https://qiantao94.github.io/tags/自定义控件/"}]},{"title":"读《编写可读代码的艺术》","slug":"《编写可读代码的艺术》-读书笔记","date":"2016-12-18T05:12:44.000Z","updated":"2019-07-24T02:08:56.518Z","comments":true,"path":"2016/12/18/《编写可读代码的艺术》-读书笔记/","link":"","permalink":"https://qiantao94.github.io/2016/12/18/《编写可读代码的艺术》-读书笔记/","excerpt":"至少解决了一大宇宙难题 —— 如何给代码命名","text":"至少解决了一大宇宙难题 —— 如何给代码命名如果觉得不错，最好去把原书看一遍！ 代码应当易于理解 关键思想：代码的写法应当使别人理解它所需的时间最小化 要把理解代码所需的时间最小化而不是减少代码，比如一条注释尽管增加了代码的长度，但是能让你更快的理解代码 先从表面改进：起好名字、写好注释、整洁的代码格式 代码命名选择专业的词 get 根据情境，用 FetchPage() 或者 DownloadPage() 代替 getPage() size() 在树中应该用 height() 表示高度，numNodes() 表示节点数，用 memoryBytes() 表示内存中所占的空间 找到更有表现力的词 单词 更多选择 send deliver、dispatch、 announce、 distribute、route find search、extract、locate、recover start launch、create、begin、open make create、set up、build、generate、compose、add、new 避免像泛泛的名字 在需要实际意义表现时，避免使用 tmp、retval、foo 这样的词 某些情况使用空泛的名字也有好处，比如说在交换两个变量的时候使用 tmp，在循环迭代器中使用 i、j、iter，但是在嵌套的循环中，加上有意义的前缀使之更能相互区分 为名字附带更多的信息 如果一个 id 是十六进制的，可以命名为 hexId 带单位的值最好附带上单位 函数参数 带单位的参数 start(int delay) delay –&gt; delay_secs createCache(int size) size –&gt; size_mb throttleDownload(float limit) limit –&gt; max_kbps rotate(float angle) angle –&gt; degree_cw 附带额外信息不仅限于单位，比如其他属性： 情形 变量名 更好的名字 一个“纯文本”格式的代码，需要加密后才能进一步使用 password plaintext_password 一条用户提供的注释，需要转义之后才能用于显示 comment unescaped_comment 已转化为UTF-8格式的html字节 html html_utf8 以“url方式编码”的输入数据 data data_urlenc 匈牙利表示法把每个变量的“类型信息”都写进名字的前缀中，例如pLast 代表一个指向最后一个元素的指针（p），个人认为在 java 中不推荐这种命名方式，因为 java 这种强类型的语言在编译期就能确定变量的类型 名字的长度 在小作用域中使用短的名字，相反在大作用域中使用长名字 现代编辑器能方便使你键入长名字 首字母缩略词和单词缩写应该是大家普遍接受和理解的，例如用 doc 代替 document、str 代替 string。 丢掉没用的词，ConvertToString 可以直接写成 toString，这样也没有丢失任何信息 利用名字的格式来传递含义，java 中，例如 情形 规则 类名 大驼峰命名法 方法、变量名 小驼峰命名法 常量名 全部大写字母，不同单词下划线分割 不论代码中采用何种规范，团队或者项目要保持一致 不会误解的名字 关键思想：要仔细审视名字，“这个名字会被别人误解成其他含义吗” 当要定一个值的上线或者下限时，max_和min_是很好的前缀 对于包含的范围，使用first和last是很好的选择 对于包含/排除的范围，begin和end是常用的选择 命名应与使用者的期望相匹配，例如：get*() 是个“轻量级访问器”，list.size() 应该是一个 O(1) 复杂度的操作 很多单词在用来编程时是多义性的，例如 filter、length 和 limit 美观三条原则 使用一致的布局，让读者很快就习惯这种风格 让相似的代码看上去相似 把相关的代码行分组，形成代码块 美观的重要性 整洁的代码能让读者花更少的时间理解代码 提高代码美观 重新安排换行来保持一致和紧凑 用方法（函数）来整理不规则的代码 可以考虑使用列对齐，例如： #Extract POST parameters to local variablesdetails = request.POST.get('details')location = request.POST.get('location')phone = request.POST.get('phone')email = request.POST.get('email')url = request.POST.get('url') 选一个有意义的顺序，始终如一的使用它 把声明按块组织起来 把代码分成有逻辑的段落：把相似的想法放在一起并与其他想法分开 一致的风格比正确的风格更重要 注释关键思想：注释的目的是尽量帮助读者了解得和作者一样多 什么不需要注释 不要为了那些从代码本身就能快速推断的事实写注释 不要为了注释而注释，没有提供比代码本身更多信息的注释要么删除，要么改进 不要给不好的名字加注释—应该把名字改好，好代码&gt;坏代码+好注释 什么需要注释 记录你写代码时重要的想法 记录对代码有价值的见解，例如：解释代码没法修复的缺陷、代码不整洁的原因 为代码中的瑕疵写注释，比如有如下几种标记： 标记 通畅的意义 TODO: 我还没有处理的事情 FIXME: 已知的无法运行的代码 HACK: 对一个问题不得不采用的比较粗糙的解决方案 XXX: 危险！这里有重要的问题 给常量加注释，记下决定这个常量值时的想法 站在读者的角度 考虑读者阅读这段代码时可能出现提问，并将提问的答案写在注释中 公布可能的陷阱 编写文件级别的注释，让读者熟悉代码库 在一个类或者函数内部编写总结性的注释 克服“作者心里阻滞”， 不管心里想什么，先把它写下来 读一下这段注释，看看有没有什么可以改进的地方 不断改进 当你经常写注释，你会发现步骤1所产生的注释会越来越好，就越不需要后面两步了 写出言简意赅的注释 让注释保持紧凑 避免使用不明确的代词 润色粗糙的句子 精确的描述函数的行为 对于输入输出，精心挑选一个例子就够了 声明代码的意图 “具名”函数的参数，就是用注释标明函数参数的含义，用来解释难以理解的函数参数 采用信息含量高的词 简化循环和逻辑把控制流变得易读关键思想：把条件、循环、以及其他对控制流的改变做的越“自然”越好。让读者不用停下来重读代码。 条件语句 条件语句中比较参数的顺序，有以下指导原则： 比较的左侧 比较的右侧 “被问询的”表达式，它的值更倾向于不断变化 用来做比较的表达式，它的值更倾向于常量 这是和日常语言习惯是一致的，我们会很自然的说：“如果你的年收入至少是10万” “尤达表示法”：在有些语言中（包括C++和C，不包括Java）为了防止 if(obj==NULL) 被写成 if(obj=NULL)，出现了 if(NULL==obj) 这样的写法，但是这样不利于理解，与上一条相悖，现代编译器已经能对 if(obj=NULL) 给出警告，所以这个写法已经过时了。 if/else语句块的顺序： 首先处理正逻辑而不是负逻辑的情况。例如，用 if(debug) 而不是 if(!debug) 先处理掉简单的情况。这种方式可能还会让if和else在屏幕内都可见 先处理有趣的或者是可疑的情况 不要为了减少代码行数而使用三目运算符，它只适用于从两个简单的值中作出选择的情况，例如： time_str += (hour &gt;= 12) ? \"pm\" : \"am\"; 因为带有复杂逻辑的三目运算符反而增加了代码的阅读时间 循环 避免 do/while 循环，它的 continue 语句会让人迷惑，while 循环相对更加易读。实践中，大多数 do/while 循环都可以写成 while 循环 从函数提前返回 函数中使用多条 return 语句是没有问题的 实现函数结尾的清理代码的更为精细的方式 语言 清理代码的结构化术语 C++ 析构函数 Java、Python try finally Python with C# using goto 语句对程序易读性的破坏 嵌套 深层次的嵌套严重影响代码的可读性 嵌套一开始是很简单的，但是后来的改动会加深嵌套 通过提早返回来减少嵌套 减少循环内的嵌套，与提早返回类似的技术是使用 continue 代码流程 编程语言和库的结构让代码在“幕后运行”，或者让代码难以理解，如： 编程结构 高层次程序流程是如何变得不清晰的 线程 不清楚什么时间执行什么代码 信号量/中断处理程序 有些代码随时有可能执行 异常 可能会从多个函数调用中向上冒泡一样地执行 函数指针和匿名函数 很难知道到底会执行什么代码，因为在编译时还没有决定 虚方法 object.virtualMethod() 可能会调用一个未知子类的代码 拆分超长表达式关键思想：把超长表达式拆分成更容易理解的小块 解释变量 引入一个额外的变量，使之成为一个小一点的子表达式 总结变量 用一个很短的名字来代替一大块代码，会更容易管理和思考 使用德摩根定理 分别进行取反、转换与/或，反向操作是提取出“反因子” 不滥用短路操作 短路操作虽然可以很智能的运用在某些场景，使之成为条件控制的效果，但是影响代码的理解 但短路操作在很多情况下也能达到简洁的目的 拆分巨大的语句 复杂的逻辑会产生复杂的表达式，表达式复杂会增加代码的阅读难度，解决它需要转换思维，用更优雅的方式 巨大的语句的拆分需要找到重复的部分，进行简化 有时需要把问题“反向”或者考虑目标的对立面 变量的可读性主要问题： 变量越多，就越难全部跟踪它们的动向 变量的作用域越大，就需要跟踪它的动向越久 变量改变得越频繁，就越难以跟踪它的当前值 减少不能改进可读性的变量 减少没有价值的临时变量，比如 没有拆分任何复杂的表达式 没有做更多的解释 只用过一次，因此没有压缩任何冗余代码 减少中间结果 减少控制流变量 while(/*condition*/&amp;&amp;!done)&#123; if(...)&#123; done = true; continue; &#125;&#125; done就是控制流变量，可以通过更好的运用结构化编程而消除： while(/*condition*/)&#123; if(...)&#123; break; &#125;&#125; 当有多个嵌套的循环时，一个 break 可能不够，通常的解决方案是把代码挪到一个新方法中 缩小变量的作用域 避免滥用全局变量 让你的代码对尽量少的代码行可见 把定义往下移，变量定义在使用之前即可 只写一次的变量更好 那些只设置一次值的变量（或者 const、final、常量）使得代码更容易理解 就算不能让变量只写一次，让变量在较少的地方改动仍有帮助 操作一个变量的地方越多，越难确定它的当前值 重新组织代码抽取那些与程序主要目的“不相关的子问题”积极的发现并抽取出不相关的子逻辑 理解某个函数或者代码块高层次的目标 对于每行代码确定它是否为目标而工作 如果有很多代码行在解决 不相关的子问题，将它抽取到独立的函数中 什么是“不相关”的子问题 完全是自包含的，并不知道其他程序是如何使用它的 纯工具的代码，例如操作字符串、使用哈希表以及读/写文件 通用的代码库 优化现有的接口 永远不要安于使用不理想的接口 创建自己的包装函数和隐藏接口的粗陋细节 按需要重塑接口 过犹不及 更多的小函数意味着更多的东西需要关注 不要为了抽取而抽取 代码应当一次只做一件事情相当于一个函数应该只做一件事情，但是一个函数也可以用空白行区分不同的事情，来达到逻辑上的清晰 列出任务 将所有任务列出来，其中一些任务可以很容易地编程单独的函数（或类） 难点在于准确描述列出的所有的小任务 分割任务 分开解决任务使代码变得更小 把想法变成代码方法 用自然语言描述程序 用这个描述来帮助你写出更自然的代码 用自然语言说事情 “小黄鸭法”解决所遇到的代码问题 如果你不能把问题说明白或者用词语来设计，估计是缺少了什么东西或者什么东西缺少定义 少写代码 重用库或者减少功能，可以节省时间并且让代码库保持精简节约 最好读的代码就是没有代码 不去费时间实现不需要的功能 没用的功能尽管很酷，但会让程序更复杂 质疑和拆分需求 从项目中消除不必要的功能，不要过度设计 重新考虑需求，解决版本最简单的问题，只要完成工作就行 让你的代码库越小，越轻量级越好 创建越多越好的“工具”以减少重复代码 减少无用代码或者没有用的功能 是项目中的子项目解耦 保持代码的轻量级 保持对标准库的API的熟悉，尽量使用标准库解决现实问题","categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://qiantao94.github.io/tags/阅读/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://qiantao94.github.io/tags/读书笔记/"}]},{"title":"[译]动画矢量图","slug":"[译]动画矢量图(简单几步就能动起来)","date":"2016-11-30T13:06:50.000Z","updated":"2019-07-24T02:08:56.519Z","comments":true,"path":"2016/11/30/[译]动画矢量图(简单几步就能动起来)/","link":"","permalink":"https://qiantao94.github.io/2016/11/30/[译]动画矢量图(简单几步就能动起来)/","excerpt":"简单几步就能动起来","text":"简单几步就能动起来 尽管 AnimatedVectorDrawableCompat（自从 2016 年二月份 – Support Library 23.2.0）已经出来有一段时间了，Google 官方却一直没有提供一份使用教程。你很难搜到相关可靠的文章，也没有什么能把这个东西完完整整的呈现出来。所以接下来我尝试将所有必要知识精简成你所能理解的东西。 你需要做的事：1.在你的 build.gradle 文件中添加 AppCompat 依赖compile 'com.android.support:appcompat-v7:25.0.0' 我使用了（此时）最新版本 25.0.0，但是只要从 23.2.0 开始任何版本可以正常工作 2.创建vector drawable（矢量图）文件 它能被赋予动画效果 vector drawable文件必须被放在你项目的 res/drawable 文件夹 更多的相关内容点这里（译注：官方文档需科学上网）&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"24dp\" android:height=\"24dp\" android:viewportHeight=\"24\" android:viewportWidth=\"24\"&gt; &lt;group android:name=\"menu\" android:pivotX=\"12\" android:pivotY=\"12\"&gt; &lt;group android:name=\"bottom_container\" android:pivotX=\"20\" android:pivotY=\"17\"&gt; &lt;path android:name=\"bottom\" android:pathData=\"M4,17,L20,17\" android:strokeColor=\"#000\" android:strokeLineCap=\"square\" android:strokeLineJoin=\"miter\" android:strokeMiterLimit=\"10\" android:strokeWidth=\"2\"/&gt; &lt;/group&gt; &lt;group android:name=\"stem_container\" android:pivotX=\"12\" android:pivotY=\"12\"&gt; &lt;path android:name=\"stem\" android:pathData=\"M4,12,L20,12\" android:strokeColor=\"#000\" android:strokeLineCap=\"square\" android:strokeLineJoin=\"miter\" android:strokeMiterLimit=\"10\" android:strokeWidth=\"2\"/&gt; &lt;/group&gt; &lt;group android:name=\"top_container\" android:pivotX=\"20\" android:pivotY=\"7\"&gt; &lt;path android:name=\"top\" android:pathData=\"M4,7,L20,7\" android:strokeColor=\"#000\" android:strokeLineCap=\"square\" android:strokeLineJoin=\"miter\" android:strokeMiterLimit=\"10\" android:strokeWidth=\"2\"/&gt; &lt;/group&gt; &lt;/group&gt;&lt;/vector&gt; 上面的代码描绘的是一个基础的黑色菜单（汉堡包）图标： 3.创建动画文件 它们指定了 vector 的动画部分 可以将多个动画分别指定给一个 vector drawable 的不同的部分 vector 不同的部分用 name 标签指定（例如 menu, bottom_container, bottom, stem_container, stem, top_container, top） 动画文件根元素既可以是 set 也可以是 objectAnimator 这些文件需要放在res/anim目录下 接下来的代码展现了 top_container 动画，它定义了四个属性，translateX，translateY，scaleX 以及 rotation:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;objectAnimator android:name=\"top_container\" android:duration=\"700\" android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" android:propertyName=\"translateX\" android:startOffset=\"500\" android:valueFrom=\"0\" android:valueTo=\"-1.41421356\" android:valueType=\"floatType\"/&gt; &lt;objectAnimator android:name=\"top_container\" android:duration=\"700\" android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" android:propertyName=\"translateY\" android:startOffset=\"500\" android:valueFrom=\"0\" android:valueTo=\"5\" android:valueType=\"floatType\"/&gt; &lt;objectAnimator android:name=\"top_container\" android:duration=\"700\" android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" android:propertyName=\"scaleX\" android:startOffset=\"500\" android:valueFrom=\"1\" android:valueTo=\"0.5\" android:valueType=\"floatType\"/&gt; &lt;objectAnimator android:name=\"top_container\" android:duration=\"700\" android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" android:propertyName=\"rotation\" android:startOffset=\"500\" android:valueFrom=\"0\" android:valueTo=\"45\" android:valueType=\"floatType\"/&gt;&lt;/set&gt; 4.创建animate-vector drawable文件 animated-vector 将所有的内容都联系在一起（vector drawable 文件和所有的 animation 文件） 需要将它放在你项目的 res/anim 目录下 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:drawable=\"@drawable/vector_menu_back\" tools:ignore=\"NewApi\"&gt; &lt;target android:name=\"top_container\" android:animation=\"@anim/anim_top_container\"/&gt; &lt;target android:name=\"stem_container\" android:animation=\"@anim/anim_stem_container\"/&gt; &lt;target android:name=\"bottom_container\" android:animation=\"@anim/anim_bottom_container\"/&gt; &lt;target android:name=\"menu\" android:animation=\"@anim/anim_menu\"/&gt;&lt;/animated-vector&gt; 需要注意的是： 如果你的 minSdkVersion 小于21（如果大于的话，那我真的不知道你为什么会考虑用 AnimatedVectorDrawableCompat…正常用 AnimatedVectorDrawable 就行了），Android Studio 可能会在你的 animated-vector 文件中弹出一个静态检查警告： 不要担心这个警告！如果你的代码没有错误，你的AnimatedVectorDrawableCompat 会忽略掉它并且能够正常工作。当然如果你不想再看到警告，可以添加 tools:ignore=&quot;NewApi&quot;： 5.编辑你的 build.gradle 文件 在你的 build.gradle 文件中，将 vectorDrawables.useSupportLibrary = true 添加进 android 部分的defaultConfig 内 你需要这行代码，这样你的 animated-vector 才能兼容API小于 Lollipop版本的系统 android &#123; compileSdkVersion 24 buildToolsVersion \"24.0.3\" defaultConfig &#123; applicationId \"com.junyuan.wukongnew\" minSdkVersion 21 targetSdkVersion 24 versionCode 1 versionName \"1.0\" vectorDrawables.useSupportLibrary = true &#125; ...&#125; 6.将你的 AnimatedVectorDrawableCompat 设置到 ImageView 或者 ImageButton 你可以用 app:srcCompat 把它添加进xml文件 &lt;ImageView android:id=\"@+id/iv_animated\" android:layout_width=\"48dp\" android:layout_height=\"48dp\" app:srcCompat=\"@drawable/animated_vector_menu_back\"/&gt; 或者通过 java 代码： final AnimatedVectorDrawableCompat avd = AnimatedVectorDrawableCompat.create(this, R.drawable.animated_vector_menu_back); animatedIv.setImageDrawable(avd); 7.在你需要的时候开启动画 获得 AnimatedVectorDrawableCompat 的引用（或者是它的一个实现类–Animatable），如果你的 AnimatedVectorDrawableCompat 是通过 java 代码添加的，可以直接使用这个对象的引用（你可以跳过这步）： final Animatable animatable = (Animatable) animatedIv.getDrawable(); 开启动画 animatable.start() 好消息和坏消息让我们先来听听好消息： 你可以很轻松通过Roman Nurik的AndroidIconAnimator这个工具（尽管当前它是预览版，但是也足够有用了）实现步骤 1-3。它可以将 svg 文件和你所指定的动画元素转换成 animated-vector drawable 文件 有一件很有意思的事情是导出来的来的 animated-vector 文件使用了 aapt 工具的一些非常厉害的功能，导出来的 drawable 文件包含了全部动画所需的代码（包括 vector drawable 和 animation 文件）。就是将步骤 1-3 的所有文件都包含在一个文件里。 坏消息来了： AnimatedVectorDrawableCompat 在 API 小于 21 时有一些限制: Chris Banes的文章中指出： animate vectors 在 API 小于 21 的平台上工作时同样有一些限制，当前在这些平台上有一下这几点限制： 路径绘制（PathType evaluator），这被用来从一个路径绘制到另一个路径 路径插值器，这被用来定义一个灵活的插值器（展现成一个路径）以代替系统自动生成的，比如说线性插值器（LinearInterpolator） 按路径移动，这很少能用到，几何图形能在限制路径上来回运动 大致意思就是你可以忘了 pathData 元素的动画 pathData，我们只能期望谷歌的天才们能研究一个方法将这个功能兼容到低版本的系统上去。 更多 似乎这里有个小 bug（除非这是它的特点），如果你尝试通过给 animated-vector 添加 startOffset 至你的动画，你的动画将根本不能运行起来（至少它在我这不行），它会从开始状态跳到结束状态（带有一些延迟），在所有的 animated-vector 中至少得有一个动画需要从开始状态运行。这是需要注意的。。。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"动画","slug":"动画","permalink":"https://qiantao94.github.io/tags/动画/"},{"name":"矢量图","slug":"矢量图","permalink":"https://qiantao94.github.io/tags/矢量图/"}]},{"title":"RxJava + BLE","slug":"使用RxJava帮助低功耗蓝牙(BLE)进行通信","date":"2016-11-25T11:54:50.000Z","updated":"2019-07-24T02:08:14.597Z","comments":true,"path":"2016/11/25/使用RxJava帮助低功耗蓝牙(BLE)进行通信/","link":"","permalink":"https://qiantao94.github.io/2016/11/25/使用RxJava帮助低功耗蓝牙(BLE)进行通信/","excerpt":"基础教程！基础教程！","text":"基础教程！基础教程！ 关于 RxJava，如果你还不了解，可以看给 Android 开发者的 RxJava 详解关于低功耗蓝牙的开发你可以看官方文档或者直接阅读本文 Android 中的蓝牙开发有两种，一种是传统蓝牙，另一种是低功耗蓝牙，这两者完全不一样，开发前你得弄清你需要开发的是哪一种，用传统蓝牙的方式进行低功耗蓝牙的开发你可能都没法使你的设备连上蓝牙，不要问我为什么知道，说多了都是泪 (TT)低功耗蓝牙（Bluetooth Low Energy）简称 BLE, 常见于各种运动手环、电子血压计等健康管理设备，Android 4.3（ API 级别 18 ）中引入了面向低功耗蓝牙的API支持。也就是说开发的前提是手机设备支持BLE并且系统是 Android 4.3 以上，与手机通信的蓝牙设备是低功耗蓝牙。如果你看了官方文档上的示例，你会发现使用了 Handler、和广播进行异步通信，现在有了 RxJava，你可以用换个方式了。 整体思路假定你已经有了一部支持 BLE 的手机和一个可以通信的低功耗蓝牙模块，那么就可以按下面的步骤开搞了： 蓝牙权限 设置并开启手机蓝牙 查找蓝牙设备 连接蓝牙服务 进行蓝牙通信 详细步骤设置蓝牙权限在应用中的 manifest 文件中声明蓝牙权限&lt;uses-permission android:name=\"android.permission.BLUETOOTH\"/&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/&gt; 另外我们可以通过 PackageManager.hasSystemFeature() 方法来判断当前的手机设备是否支持BLE。 设置并开启手机蓝牙设备首先通过 BluetoothManager 获取手机中唯一的的蓝牙适配器(蓝牙发送接收器) BluetoothAdapter 对象。再通过 BluetoothAdapter 开启手机蓝牙设备，代码如下：public void initBle(Context context) &#123; this.mContext = context.getApplicationContext(); BluetoothManager bluetoothManager = (BluetoothManager) this.mContext.getSystemService(Context.BLUETOOTH_SERVICE); mBleAdapter = bluetoothManager.getAdapter(); if (mBleAdapter != null) &#123; mBleAdapter.enable();//不弹对话框直接开启蓝牙 &#125; &#125; 值得一提的是我将蓝牙功能简单的封装成了一个工具类，用到了静态内部类的单例模式，为了防止内存泄露，在初始化蓝牙的时候传入了 Application 的 Context 对象的引用 查找蓝牙设备定义了一个 scanBleDevices(boolean enable) 方法用于开启和关闭扫描。这里使用了 BluetoothAdapter.startLeScan(LeScanCallback) 方法开启扫描，需要传入一个扫描回调： private BluetoothAdapter.LeScanCallback mBleScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(BluetoothDevice bleDevice, int rssi, byte[] scanRecord) &#123; if (mIsScanning) &#123; Log.d(TAG, \"onLeScan：找到设备\" + bleDevice.getName()); if (mTargetDeviceName.equals(bleDevice.getName())) &#123; connectDevice(bleDevice);//连接蓝牙设备 &#125; &#125; else &#123; Log.d(TAG, \"onLeScan: 停止扫描\"); &#125; &#125;&#125;; 这个回调也用于关闭蓝牙扫描的方法 BluetoothAdapter.stopLeScan(LeScanCallback)，所以定义了一个布尔型变量 mIsScanning 判断蓝牙扫描的开启和关闭。 说了这么多，我们的 RxJava 好像还没登场。在扫描过程中，我们需要限定蓝牙的扫描的超时时间，不能让手机这么一直扫描，所以我们可以通过 RxJava 中的timer延时一段时间后执行停止扫描：Observable.timer(SCAN_PERIOD, TimeUnit.MILLISECONDS).subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; mIsScanning = false; mBleAdapter.stopLeScan(mBleScanCallback); &#125;&#125;); 连接蓝牙服务并接收数据 当查找到名为 mTargetDeviceName 的目标蓝牙设备，就可以通过下面的方法去连接，准确的说是连接设备上的 GATT 服务：private void connectDevice(BluetoothDevice bleDevice) &#123; scanBleDevices(false); mBleGatt = bleDevice.connectGatt(mContext, true, new BleGattCallback()); mBleGatt.connect(); Log.d(TAG, \"开始连接设备：\" + mBleGatt.getDevice().getName());&#125; 连接蓝牙设备前需要关闭蓝牙扫描。 bleDevice.connectGatt(mContext, true, new BleGattCallback()) 方法返回了一个蓝牙GATT对象，这个方法中的 true 代表自动连接（蓝牙模块断电重启后，可以重新连接它），调用 GATT 的 connect() 方法进行连接，连接过程中会执行传入的回调 BleGattCallback，这个回调继承了 BluetoothGattCallback 并重写了以下三个方法： 一、onConnectionStateChange@Overridepublic void onConnectionStateChange(BluetoothGatt bleGatt, int status, int newState) &#123; super.onConnectionStateChange(bleGatt, status, newState); Log.d(TAG, \"onConnectionStateChange: 连接状态: \" + newState); if (newState == BluetoothGatt.STATE_CONNECTED) &#123;//连接成功 Log.d(TAG, \"onConnectionStateChange: 设备连接\"); bleGatt.discoverServices();//搜索服务 &#125; else if (newState == BluetoothGatt.STATE_DISCONNECTED) &#123;//断开连接 Log.d(TAG, \"onConnectionStateChange: 设备断开\"); &#125;&#125; 这个方法监听连接状态的改变，连接状态有四个值： 值 描述 STATE_CONNECTED 已连接 STATE_CONNECTING 正在连接 STATE_DISCONNECTED 断开连接 STATE_DISCONNECTING 正在断开连接 当设备已连接时，需要通过 discoverServices() 查找 GATT 服务，查找服务过程中会执行重写的第二个方法 onServicesDiscovered。 二、onServicesDiscovered可以在此方法中获取 GATT 的服务列表，这个服务列表中的每一个服务对应着一个 BluetoothGattCharacteristic（用于通信）列表，需要对这个列表通过 UUID 过滤出我们想要的 BluetoothGattCharacteristic，然后就可以拿这个 BluetoothGattCharacteristic 进行通信了。 关于 UUID通用唯一标识符 (UUID) 是用于唯一标识信息的字符串 ID 的 128 位标准化格式。 UUID 的特点是其足够庞大，因此你可以选择任意随机值而不会发生冲突。 在此示例中，它被用于唯一标识应用的蓝牙服务。 要获取 UUID 以用于你的应用，你可以使用网络上的众多随机 UUID 生成器之一，然后使用 fromString(String) 初始化一个 UUID。不必过多纠结于 UUID。 上面这个过程如果用传统的方式编写的话，那就是列表遍历嵌套列表遍历再嵌套 if 判断 ，下次再看的话就是一堆迷之缩进，还好可以用 RxJava 写出链式的结构：@Overridepublic void onServicesDiscovered(final BluetoothGatt bleGatt, int status) &#123; Log.d(TAG, \"onServicesDiscovered: 查找服务: \" + bleGatt.getServices().size()); List&lt;BluetoothGattService&gt; serviceList = bleGatt.getServices(); Observable.from(serviceList) .flatMap(new Func1&lt;BluetoothGattService, Observable&lt;BluetoothGattCharacteristic&gt;&gt;() &#123; @Override public Observable&lt;BluetoothGattCharacteristic&gt; call(BluetoothGattService bleGattService) &#123; return Observable.from(bleGattService.getCharacteristics()); &#125; &#125;) .filter(new Func1&lt;BluetoothGattCharacteristic, Boolean&gt;() &#123; @Override public Boolean call(BluetoothGattCharacteristic bleGattChar) &#123; return bleGattChar.getUuid().toString().equals(UUID); &#125; &#125;) .subscribe(new Action1&lt;BluetoothGattCharacteristic&gt;() &#123; @Override public void call(BluetoothGattCharacteristic bleGattChar) &#123; bleGatt.setCharacteristicNotification(bleGattChar, true);//设置开启接收蓝牙数据 mBleGattChar = bleGattChar; &#125; &#125;);&#125; 三、onCharacteristicChanged此方法用于接收蓝牙模块发送过来的数据，它是异步的，可以用 RxJava 方便的切换到 Android 主线程：@Overridepublic void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; Log.d(TAG, \"onCharacteristicChanged\"); String receiveData = new String(characteristic.getValue()); Log.d(TAG, \"收到蓝牙发来数据：\" + receiveData); Observable.just(receiveData) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String receiveData) &#123; //处理receiveData &#125; &#125;);&#125; 前面提到了整个蓝牙功能是一个工具类，那么我们怎么在我们想要的地方（Activity）接收到这个 receiveData 呢？也许你会说可以在这里写一个接口回调啊，是的没问题。在了解到可以通过 RxJava 实现 EventBus 事件总线后，我想可以写一个简单的RxBus 在这里发射数据，在需要的地方订阅并接受数据。 关于 RxBus，你可以先看implementing-an-event-bus-with-rxjava-rxbus，然后可以看state-propagation-in-android-with-rxjava-subjects（需要科学上网）。此外，国内也有很多相关文章。 先定义一个 Subject，它既是观察者又是被观察者private Subject&lt;String, String&gt; mBus = new SerializedSubject&lt;&gt;(PublishSubject.&lt;String&gt;create()); 然后在 处理 receiveData 的地方发射数据mBus.onNext(receiveData); 再定义一个方法用于接收数据public Observable&lt;String&gt; receiveData() &#123; return mBus;&#125; 最后在需要接收数据的地方订阅mRxBle.receiveData().subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String receiveData) &#123; sendTv.setText(mStringBuffer.append(receiveData).append(\"\\n\")); &#125;&#125;); 向蓝牙设备发送数据通信不仅仅是接收数据，还需要发送数据，这个实现起来很简单，只要使用我们之前拿到的 BluetoothGattCharacteristic 对象以及BluetoothGatt 对象进行相关方法的调用就行，在项目中由于需要对数据进行延时发送，所以也用到了 timer：Observable.timer(time, TimeUnit.MILLISECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long l) &#123; if (mBleGatt != null &amp;&amp; mBleGattChar != null) &#123; mBleGattChar.setValue(data);//设置数据 boolean isSend = mBleGatt.writeCharacteristic(mBleGattChar);//写入（发送）数据 Log.d(TAG, \"发送：\" + (isSend ? \"成功\" : \"失败\")); &#125; &#125; &#125;); RxJava 的强大之处在于他有各种各样的操作符，可以对发布的数据源进行各种各样的处理，实际项目中有很多应用的场景。 传送门：RxBleDemo","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://qiantao94.github.io/tags/RxJava/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://qiantao94.github.io/tags/蓝牙/"}]},{"title":"2016 年末的书单","slug":"年前书单计划","date":"2016-11-09T15:43:20.000Z","updated":"2018-06-13T13:11:56.935Z","comments":true,"path":"2016/11/09/年前书单计划/","link":"","permalink":"https://qiantao94.github.io/2016/11/09/年前书单计划/","excerpt":"先定一个小目标，把这些书读完！","text":"先定一个小目标，把这些书读完！ 编写可读代码的艺术 代码整洁之道 RxJavaEssentials Learning Reactive Programming","categories":[],"tags":[{"name":"书单","slug":"书单","permalink":"https://qiantao94.github.io/tags/书单/"}]},{"title":"[译]闪屏页的正确使用","slug":"[译]闪屏页的正确使用","date":"2016-11-03T11:40:20.000Z","updated":"2019-07-24T02:08:56.518Z","comments":true,"path":"2016/11/03/[译]闪屏页的正确使用/","link":"","permalink":"https://qiantao94.github.io/2016/11/03/[译]闪屏页的正确使用/","excerpt":"App 的「冷启动」及「热启动」","text":"App 的「冷启动」及「热启动」 前言 最近看了一篇关于 App 启动页的文章，作者介绍了如何使闪屏页用正确的延时跳转到主界面，虽然文章是去年写的，但是作者推荐的启动页最小化延时的方法倒是挺符合当下火热的 ReactiveX 的思想：Less is More。当然为了营销在启动页植入广告是另一种使用场景。 原文链接：Splash Screens the Right Way，作者：Chris Stewart 如有译误，请指出。 正文 一想到闪屏我就有点生气，只是说这个词让我感觉不舒服。 闪屏页就是浪费你的时间，对吧？作为一个 Android 开发者，当我看见一个闪屏页面，我就会想到一些可怜的开发者不得不在自己的代码中塞入三秒的延时。 然后，我就得花三秒钟盯着这些图片直到我可以用这个应用，而且每当我启动它的时候我都得这样做，我知道我打开的是哪个应用，我也知道这个应用的功能，能不能让我直接快乐的玩耍。 Google的建议 你可能会惊讶Google竟然会提倡你去使用闪屏页，在 Material Design 规范中的这里提到了（译注：需科学上网）。 因为之前可不是这样的，Google 曾经主张反对闪屏页，甚至称之为反面教材（译注：需科学上网）。 为什么？ 闪屏页的正确使用 我认为 Google 并不是自相矛盾的，旧理念和新立场可以并存（这么说吧，使用闪屏页面去耗费用户的时间仍然不是一个好的想法，请不要那样做）。 然而，Android 的众多应用的确需要一定量的时间去启动，尤其是在冷启动上，这个延时启动你是无法避免的，与其在启动的时候留着白屏，为何不给用户展示有用的东西？这才是 Google 所倡导的方式。在用户第一次启动的时候，不要浪费用户的时间，但是也不要给他们留白屏。 如果你去看最近 Google 的一些应用的更新，你会看到闪屏页合理的使用。例如，YouTube 的应用： 你看闪屏所花费的时间，就是应用配置自己去启动所需要的时间。在冷启动上也是这样的，这就意味着这可能是启动比较缓慢。如果应用有缓存，闪屏界面将会几乎立即跳转。 闪屏页的实现 实现一个闪屏页的正确方式可能和你想象的有些不同，你得先准备好你所看到的 splash view，甚至先于给你的 SplashActivity 准备好一个布局文件。 所以你都用不着布局文件，代替它的是将 activity 的主题背景指定为闪屏背景。实现这个，第一步是在 res/drawable 目录下创建一个 XML drawable。 注：所有的代码都在 Github 上。&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@color/gray\"/&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/ic_launcher\"/&gt; &lt;/item&gt; &lt;/layer-list&gt; 这里我设置了一个背景色和一张图片。 然后，你要将这个设置到 SplashActivity 的主题中作为背景。进入你的 style.xml 文件，然后为闪屏页添加一个新的主题：&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;/style&gt; &lt;style name=\"SplashTheme\" parent=\"Theme.AppCompat.NoActionBar\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/background_splash&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 在你新建的 SplashTheme 中设置它的 windowBackground 属性为你之前建的 XML drawable，然后到 AndroidManifest.xml 中，将这个主题配置给你的 SplashActivity&lt;activity android:name=\".SplashActivity\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 最后，你的 SplashActivity 应该能直接跳转到MainActivitypublic class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; 注意你不需要为你的 SplashActivity 设置一个视图，这个视图来自于主题，在主题中为你的 SplashActivity 设置 UI 就足够了。 如果你的确需要为你的闪屏页设置一个布局文件，那这个布局文件将只在你的应用完全初始化完后才显示，这太迟了。因为在应用完成初始化之前，这个闪屏页只展示很短的时间。 预期结果 执行完这些步骤，你就以正确的方式完成了这个闪屏页： 学会了以上的知识，让你的闪屏页正确的运转起来。不要浪费用户的时间，并且在用户等待的时候展示给他们有用的东西。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://qiantao94.github.io/tags/Android/"},{"name":"启动页","slug":"启动页","permalink":"https://qiantao94.github.io/tags/启动页/"},{"name":"闪屏","slug":"闪屏","permalink":"https://qiantao94.github.io/tags/闪屏/"},{"name":"翻译","slug":"翻译","permalink":"https://qiantao94.github.io/tags/翻译/"}]},{"title":"在 VSCode 上开发 React-Native","slug":"使用VSCode开发React-Native的正确姿势","date":"2016-10-25T15:17:10.000Z","updated":"2019-07-24T02:08:04.485Z","comments":true,"path":"2016/10/25/使用VSCode开发React-Native的正确姿势/","link":"","permalink":"https://qiantao94.github.io/2016/10/25/使用VSCode开发React-Native的正确姿势/","excerpt":"Windows 平台搭建教程","text":"Windows 平台搭建教程 前言使用 VSCode 开发 React-Native 是个不错的选择，因为这个编辑器十分简洁、流畅，并且微软官方提供了 React Native Tools 插件，支持代码高亮、debug 以及代码提示等十分强大的功能，并且 VSCode 本身的代码跳转十分优秀。但是我下载了此插件，发现其他功能正常，唯独代码没法正确提示，右下角也没有显示 salsa 。经过我的不懈 Google 以及查看官方文档：JavaScript in VS Code，最终找到了替代解决方案。 解决方案一、配置 Typescript1.全局安装 typescript npm install typescript@next -g 当我们重启 VSCode 会得到提示：全局安装的typescript 与 VSCode 所指向的版本号不一致，所以我们要进行下一步操作。 2.配置用户设置 settings.json，通过 文件&gt;首选项&gt;用户设置 即可打开。 指定 typescript 的 lib 文件夹的路径，这个路径在安装完成时如上图所示，根据我的安装路径，对用户设置添加如下更改： &quot;typescript.tsdk&quot;: &quot;C:/Users/钱涛/AppData/Roaming/npm/node_modules/typescript/lib&quot; 重启后你的 VSCode 的下方会显示出 Typescript 的版本号。 有了以上的设置，我们从 react-native 包中引入组件模块时就会有相应的提示，我们还可以进行进一步的设置 二、配置 TypeScript Definition Files (Typings)官方对其是这样解释的： You get VS Code IntelliSense for third-party libraries and modules with type definition *.d.ts files. TypeScript definition files are written in TypeScript so they can express the data types of parameters and functions, allowing VS Code to provide a rich IntelliSense experience. 大体意思就是通过 Typings 能对第三方库例如咱们所使用的 react-native 进行其变量及方法的提示。 1.全局安装 typings npm install typings --global 2.在当前项目根目录安装相应的 typings 包 可以在 VSCode 中通过快捷键 Ctrl+Shift+C 打开控制台并定位到当前项目的根目录，然后全局安装： typings install dt~react-native --save --global 并且你的 VSCode 的根目录下会多一个 typings.json 文件。 至此配置完以后编写代码就会可以自动提示补全 并且鼠标移过去还能有相应的文档提示了 插件推荐为了开发的便捷，我还推荐以下插件： Auto Close Tag 自动闭合标签 Auto Rename Tag 自动重命名标签，配合上面的插件使用，基本上能赶上IntelliJ IDEA系的功能了 Reactjs code snippets react的代码提示，如 componentWillMount 方法可以通过 cwm 直接获得 Path Intellisense 文件路径提示补全","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://qiantao94.github.io/tags/VSCode/"},{"name":"React-Native","slug":"React-Native","permalink":"https://qiantao94.github.io/tags/React-Native/"},{"name":"编辑器配置","slug":"编辑器配置","permalink":"https://qiantao94.github.io/tags/编辑器配置/"}]},{"title":"烟花","slug":"firework","date":"2016-02-22T14:10:12.000Z","updated":"2018-07-19T11:22:22.899Z","comments":true,"path":"2016/02/22/firework/","link":"","permalink":"https://qiantao94.github.io/2016/02/22/firework/","excerpt":"","text":"仰望 绽放 散出一片亮光 绽放 仰望 飞去谁家窗台被吸引的目光，不能照亮我胸膛","categories":[],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"https://qiantao94.github.io/tags/诗歌/"}]},{"title":"下雨，见你","slug":"rain-meet","date":"2014-06-10T11:09:52.000Z","updated":"2018-07-19T11:23:59.630Z","comments":true,"path":"2014/06/10/rain-meet/","link":"","permalink":"https://qiantao94.github.io/2014/06/10/rain-meet/","excerpt":"","text":"想你有两种方式 眼内 心底 见你有两种方式 看你 抱你 一场大雨这城市就陌生了 一见到你我就又是全新的了 我把下雨和见你叫做洗礼 世界上美好的东西不太多 立秋傍晚从河对岸吹来的风 二十来岁笑起来要人命的你","categories":[],"tags":[{"name":"诗歌","slug":"诗歌","permalink":"https://qiantao94.github.io/tags/诗歌/"}]}]}